# Solana 트랜잭션 & 컨센서스 플로우

## 🔄 트랜잭션 생명주기 11단계

### 1. 트랜잭션 수신
- 클라이언트 → **RPC 노드**로 트랜잭션 전송

### 2. RPC → 검증자
- RPC 노드가 **검증자**에게 트랜잭션 전달
- **QUIC** 프로토콜 사용
- 어떤 검증자가 받을지는 **bandwidth stake(스테이크 가중 대역폭)**에 따라 선택

### 3. 검증자 → 리더
- 검증자가 **리더**에게 트랜잭션 릴레이
- 총 트랜잭션 중 **80%**는 `staked-weighted QoS(swQOS)` 경로, **20%**는 일반 경로 사용

### 4. 리더 처리
- 리더가 트랜잭션 수신 → **Signature Verify** → **Banking Stage** 진입
- 여기서 계좌 상태(state) 변경
- 동시에 **PoH(Proof of History)** 해시 생성

### 5. 블록 완성 & 전파 준비
- Bank 업데이트 완료 시, 리더는 완성된 **블록 + PoH 해시**를 다른 검증자에게 전파

### 6. 터빈(Turbine) 프로토콜
- **Turbine** = 블록 데이터를 여러 **Shred**로 분할
- Shred마다 **루트 노드**를 돌려가며 병렬 전송 (트리 방식)

### 7. 검증자 수신
- 검증자들은:
  - 블록 Shred 수신
  - PoH 해시 수신 → **자체 PoH** 업데이트
  - 받은 Shred를 자신의 **Turbine 하위 노드**로 재전송

### 8. TVU(Transaction Validation Unit)
- 모든 Shred 검증 완료 시 **로컬 Bank** 업데이트
- 전체 과정은 **TVU** 모듈 내부에서 동작

### 9. Replay Stage (TVU 핵심)
- **Replay Stage**에서 대부분의 핵심 로직 실행:
  - 블록 **투표(voting)**
  - **PoH reset**
  - Bank(state) 변경 반영
  - 차기 **리더 전환**

### 10. PBFT 스타일 합의
- Solana는 **PBFT 기반** 합의를 수행하되,
- **PoH clock** 덕분에 노드 간 통신을 최소화하면서 투표 가능

### 11. Solana의 체인 품질
**장점:**
- **슬롯(slot)마다 단 하나의 리더**만 블록을 제안 가능
- 전 노드가 PoH로 시간 동기화 → **포크 확률 감소**
- 이더리움 등 **전파 기반(Propagation)** 체인 대비 동일 높이(height)에 서로 다른 상태가 존재할 가능성이 낮음

---

## 🏗️ 솔라나의 블록 빌딩

### 연속적 블록 생성 방식
- 대부분의 블록체인: 블록을 모두 조립한 뒤 전파하는 **불연속적** 방식
- 솔라나: **연속적인 블록 생성** 방식으로 할당된 시간 슬롯 동안 실시간 조립 및 스트리밍

### 타이밍 구조
| 항목 | 값 | 설명 |
|------|-----|------|
| 각 슬롯 지속 시간 | 400ms | 하나의 슬롯이 유지되는 시간 |
| 연속 할당 슬롯 수 | 4개 | 한 리더가 연속으로 받는 슬롯 |
| 총 리더 시간 | 1.6초 | 4개 슬롯의 총 시간 |

### 리더 준비 과정
- 리더가 되기 **2슬롯 전**: 트랜잭션 전달 중단하고 준비
- 이 기간 동안 **기가바이트/초** 수준의 트래픽 폭증
- 네트워크 전체가 곧 리더가 될 노드에게 패킷 집중 전송

### TPU (Transaction Processing Unit)
블록 생성의 핵심 로직을 담당하는 검증자 내부 모듈

#### 처리 단계
1. **Fetch Stage**: QUIC 네트워킹 프로토콜을 통해 트랜잭션 수신
2. **SigVerify Stage**: 엄격한 유효성 검증
   - 서명 검증
   - 서명 개수 확인
   - 중복 트랜잭션 검사
3. **Banking Stage**: 블록 생성 과정의 핵심 단계

---

## 🏦 Banking Stage

### 개념
- **Bank**: 특정 블록 시점에서의 상태 스냅샷
- 블록마다 솔라나는 해당 블록 시점의 상태 스냅샷 bank를 보유
- 블록이 충분한 검증자 투표를 받아 최종화(Finalized)되면 bank의 변경사항이 디스크에 영구 저장

### 병렬 처리 특징
- 트랜잭션들은 **병렬로 처리**되며 **엔트리**라 불리는 기록으로 묶임
- 각 엔트리는 **충돌이 없는 64건의 트랜잭션**을 모아 구성
- 각 트랜잭션은 읽고 쓸 **모든 계정 목록을 미리 명시**해야 함

### 충돌 처리 방식
- **충돌 발생**: 같은 계정을 동시에 쓰거나, 하나는 읽고 다른 하나는 쓰는 경우
- **충돌 트랜잭션**: 서로 다른 엔트리에 배치되어 순차적 실행
- **비충돌 트랜잭션**: 같은 엔트리에 배치되어 병렬 처리

### 멀티 스레드 처리
- **총 6개 스레드**가 동시에 트랜잭션 처리
  - **4개**: 일반 트랜잭션 처리
  - **2개**: 투표 트랜잭션 전담
- 모든 병렬 처리는 **CPU 멀티코어** 활용
- **GPU 요구사항 없음**

### 트랜잭션 실행 과정
1. 트랜잭션을 엔트리로 묶기
2. 필요한 계정들을 모두 잠금
3. 트랜잭션 최신성 및 중복 이력 확인
4. 계정 불러오기 및 트랜잭션 로직 실행
5. 계정 상태 갱신
6. 엔트리 해시를 PoH 서비스에 전송하여 기록
7. 성공 시 bank에 변경사항 커밋 및 계정 잠금 해제

### SVM (Solana Virtual Machine)
- 트랜잭션 실행 담당
- **rBPF 라이브러리**를 솔라나가 포크해서 제작
- **eBPF 프로그램**을 위한 **JIT 컴파일** 및 가상 머신 기능 제공

---

## 🌪️ Turbine 프로토콜

### 개념
- 리더가 자신의 블록을 네트워크에 전파하는 과정
- **비트토렌트(BitTorrent)**에서 영감을 받아 설계
- 통신 오버헤드 감소 및 리더 전송 데이터량 최소화

### Shreds (슈레드)
- 블록 데이터를 분해한 **작은 데이터 패킷**
- 비디오 스트림의 개별 프레임과 유사
- **최대 1280바이트** 크기
- **UDP**를 사용하여 검증자들 간 전송

### 성능 지표
| 항목 | 값 | 설명 |
|------|-----|------|
| 최대 Shred 크기 | 1280바이트 | 개별 Shred의 최대 크기 |
| FEC 배치당 Shred 수 | 64개 | 32개 데이터 + 32개 복구 |
| 최대 복구 가능 손실률 | 50% | 절반까지 손실되어도 복구 가능 |
| 실제 팬아웃 값 | 200 | 솔라나의 실제 팬아웃 설정값 |

### 소거 코딩 (Erasure Coding)
- **다항식 기반** 오류 검출 및 수정 방식
- 데이터 무결성 보장
- 일부 Shreds 손실되어도 블록 재구성 가능

### FEC (Forward Error Correction) 배치
- Shreds는 **FEC 배치**로 그룹화
- 기본 구성: **64개 Shreds** (32개 데이터 + 32개 복구)
- 배치 내 패킷의 **절반까지 손실**되어도 모든 데이터 복구 가능

### Turbine Tree 구조
- 검증자들이 **층(Layer)**으로 조직되어 트리 형성
- **지분이 많은 검증자**: 트리 상단 배치
- **지분이 적은 검증자**: 트리 하단 배치
- 일반적으로 **2-3개의 홉(hops)** 보유

### 보안 및 검증
- 각 64 Shreds 배치는 **머클화(Merklelized)**
- **머클 루트**는 리더에 의해 서명되고 이전 배치에 연결
- 보안상 이유로 **트리 순서는 각 새로운 Shreds 배치마다 회전**

### 핵심 목표
> **리더와 루트 노드의 외부 데이터 이탈 압력 완화**
> 
> 송신 및 재송신 시스템을 활용하여 부하를 리더와 재송신자들 간에 분산

---

## 📊 핵심 개념 요약

### 1. 슬롯(Slot)
- 솔라나는 **PoH 해시 체인**을 기반으로 시간 측정
- 이 "한 구간" 동안 리더가 트랜잭션을 모아서 검증하고 기록
- 매 슬롯마다 새로운 **블록(Entry)** 또는 **여러 개의 Entry** 생성
- 검증자들은 **슬롯 번호(Slot Number)**를 기준으로 블록체인 진행
- 슬롯 번호가 높을수록 **더 나중의 블록**을 의미

### 2. Bank와 Entry

#### Bank
- 각 슬롯마다 트랜잭션 실행 결과를 관리하는 **Bank 객체** 존재
- 슬롯 단위로 **네트워크 전체 상태를 스냅샷** 형태로 보유

#### Entry
- 슬롯 또는 Bank가 처리한 트랜잭션들을 묶어서 기록하는 구조체
- **PoH 해시 체인**에 따라 순서 결정
- 블록의 역할 수행
- 보통 **여러 Entry가 한 슬롯**에 담길 수 있음
- 최종적으로 **슬롯 번호 + Entry 내용**이 하나의 블록처럼 취급

### 3. 처리 과정

#### 1단계: 리더 선정
- **PoS에 따른 무작위성** + **라운드 로빈** 기반 리더 선출
- 리더는 일정 시간(슬롯 기간) 동안 트랜잭션 수집

#### 2단계: PoH 해시 체인으로 시점 확정
- 리더는 트랜잭션을 받는 대로 **PoH 해시 체인 지속 업데이트**
- 해시 체인을 기반으로 **트랜잭션 순서 확정**
- 가능한 트랜잭션들은 **병렬 엔진**으로 실행

#### 3단계: Bank 상태 업데이트
- 트랜잭션 실행 결과는 **Bank 객체**에서 계정 상태 변화로 반영

#### 4단계: Entry(블록) 생성 및 전파
- 리더는 **PoH 해시와 함께 Entry** 생성 후 네트워크에 전파
- 다른 검증자는 받은 Entry를 **재검증**하여 동일한 결과 상태 확인

#### 5단계: Tower BFT 투표 및 확인
- 검증자들은 **"이 슬롯은 유효하다"**라고 투표
- **Tower BFT 합의** 과정을 거쳐 일정 수의 네트워크 참여자 동의 시 해당 슬롯 블록 확정(Finalize)

---

## 🌐 QUIC 네트워킹 프로토콜

### 개요
- **2022년 말** 솔라나에서 리더 교체 트랜잭션 관리를 위해 적용
- **UDP 기반** 네트워킹 프로토콜
- **구글**에서 주도적으로 개발, 현재 **IETF 표준화** 진행 중

### 주요 특징
- **TCP 대비 간소화된 핸드셰이크** → 지연 감소
- **TLS 기반 보안**을 UDP 레벨에서 바로 제공
- **스트림 다중화** 지원으로 단일 연결에서 여러 스트림 동시 전송
- 네트워크 상태 변화 및 빠른 연결 재설정 상황에서 유리

### 솔라나에서 QUIC 사용 이유

#### 1. 저지연 & 빠른 재연결
- 솔라나 블록 생성 간격: **매우 짧은 수백ms 단위**
- 슬롯 변경 빈번
- 새로운 리더 선정 시 모든 검증자가 **새 리더와 빠른 연결** 필요
- 트랜잭션 Shred 및 기타 메시지 수신을 위해 **빠른 핸드셰이크** 필수

#### 2. UDP 기반 높은 성능 및 병렬 처리
- **초당 수천-수만개** 트랜잭션 처리 필요
- 대량 데이터 네트워크 전송 시 **성능 저하 방지** 중요
- 기존 TCP: 혼잡 제어, 순차적 패킷 전송으로 **대역폭 제한**
- QUIC: **UDP 기반**으로 스트림 단위 오류 격리 및 재전송으로 **전체 연결 병목 감소**

#### 3. 안정적 암호화와 흐름 제어
- **TLS 1.3 암호화** 기본 적용으로 안전성 확보
- **애플리케이션 레벨**에서 흐름 제어 쉽게 튜닝 가능

---

## 🎯 솔라나의 핵심 장점

### 성능 지표
| 항목 | 값 | 설명 |
|------|-----|------|
| 초당 트랜잭션 처리량 | 65,000+ TPS | 실제 처리 가능한 트랜잭션 수 |
| 평균 블록 시간 | 400ms | 각 슬롯의 지속 시간 |
| 평균 트랜잭션 수수료 | $0.00025 | 매우 낮은 수수료 |
| 리더당 할당 시간 | 1.6초 | 4개 슬롯의 총 시간 |
| Banking Stage 처리 스레드 | 6개 | 4개 일반 + 2개 투표 전담 |
| 엔트리당 최대 트랜잭션 | 64개 | 충돌 없는 트랜잭션 묶음 |

### 핵심 장점

#### ✅ 고성능 처리
- 초당 수만 건의 트랜잭션을 **400ms 블록 시간**으로 처리
- **병렬 실행 엔진**으로 효율적 처리

#### ✅ 저지연 네트워크
- **QUIC 프로토콜**과 **Turbine**을 통한 효율적 데이터 전파
- **UDP 기반** 고성능 네트워킹

#### ✅ 병렬 실행
- 트랜잭션 충돌 방지를 통한 **멀티 스레드 병렬 처리**
- **CPU 기반** 처리로 GPU 불필요

#### ✅ 확정성 보장
- **PoH 기반 시간 동기화**로 네트워크 상태 일관성 유지
- **포크 확률 감소**

#### ✅ 효율적 합의
- **PBFT + PoH**로 통신 오버헤드 최소화
- **Tower BFT** 합의 메커니즘

### 체인 품질 특징

> **"슬롯마다 단 하나의 리더만 블록을 제안 가능하며, 전 노드가 PoH로 시간 동기화하여 포크 확률을 감소시킵니다. 이더리움 등 전파 기반(Propagation) 체인 대비 동일 높이(height)에 서로 다른 상태가 존재할 가능성이 낮습니다."**

- **슬롯당 리더 수**: 1개
- **시간 동기화**: PoH 방식
- **포크 확률**: 낮음
- **블록 생성 방식**: 연속적

---

## 🔮 미래 전망

### 개발 중인 기술들

#### 🔄 SVM 롤업
- **Solana Virtual Machine**을 활용한 레이어 2 솔루션
- 확장성을 더욱 향상시킬 예정

#### 🗜️ ZK Compression
- **영지식 증명**을 통한 데이터 압축
- 스토리지 효율성과 처리 속도 개선

#### 🌍 글로벌 채택
- **DeFi, NFT, GameFi** 등 다양한 분야에서 생태계 확장
- 지속적인 개발자 및 사용자 유입

#### ⚡ 성능 최적화
- 하드웨어 발전과 함께 **소프트웨어 최적화**
- 더 높은 성능 달성 목표

---

## 📚 참고 자료

### 공식 문서
- [Solana Documentation](https://docs.solana.com/)
- [Solana Architecture Overview](https://docs.solana.com/architecture)
- [Solana Programming Model](https://docs.solana.com/programming-model)

### 기술 사양
- [Proof of History](https://docs.solana.com/architecture/proof-of-history)
- [Turbine](https://docs.solana.com/architecture/turbine)
- [QUIC Protocol](https://docs.solana.com/architecture/quic)

### 개발자 리소스
- [Solana Developer Hub](https://developers.solana.com/)
- [Solana GitHub](https://github.com/solana-labs/solana)
- [Solana Community](https://solana.com/community)

---

*이 문서는 Solana의 트랜잭션 처리 및 컨센서스 메커니즘에 대한 종합적인 가이드입니다. 지속적으로 업데이트되는 Solana 생태계의 최신 정보는 공식 문서를 참조하시기 바랍니다.*
