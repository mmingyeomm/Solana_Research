<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Solana Bootcamp - The Camp: GROUND</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html {
      scroll-snap-type: y mandatory;
    }
    body {
      font-family: 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #1a1025;
    }
    .slide {
      background-color: #faf9fc;
      min-height: 100vh;
      width: 100%;
      padding: 60px 80px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      scroll-snap-align: start;
      border-bottom: 1px solid #e0e0e0;
    }
    .slide > * {
      max-width: 1200px;
      width: 100%;
    }
    .slide-title {
      background: linear-gradient(135deg, #2d1b4e 0%, #1a1025 100%);
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .slide-title img {
      width: auto;
      height: auto;
      max-height: 80vh;
      object-fit: contain;
      border-radius: 12px;
    }
    h1 {
      color: #9945FF;
      font-size: 3.5em;
      margin-bottom: 20px;
      border-bottom: 3px solid #9945FF;
      padding-bottom: 15px;
    }
    h2 {
      color: #9945FF;
      font-size: 2.5em;
      margin-top: 20px;
      margin-bottom: 20px;
    }
    h3 {
      color: #14F195;
      font-size: 1.8em;
      margin-top: 20px;
    }
    h4 {
      color: #00D1FF;
      font-size: 1.4em;
      margin-top: 15px;
    }
    p, li {
      font-size: 1.2em;
    }
    img {
      max-width: 100%;
      max-height: 50vh;
      height: auto;
      display: block;
      margin: 30px auto;
      border-radius: 4px;
    }
    ul, ol {
      padding-left: 25px;
    }
    li {
      margin-bottom: 8px;
    }
    .highlight {
      background-color: rgba(153, 69, 255, 0.08);
      border-left: 4px solid #9945FF;
      padding: 10px 15px;
      margin: 20px 0;
    }
    .two-column {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }
    .column {
      flex: 1;
    }
    .note {
      font-style: italic;
      color: #666;
      font-size: 0.9em;
    }
    .diagram {
      text-align: center;
      margin: 20px 0;
    }
    .caption {
      text-align: center;
      font-style: italic;
      color: #666;
      margin-top: 5px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    .stat-card {
      background-color: rgba(153, 69, 255, 0.06);
      border: 1px solid rgba(153, 69, 255, 0.2);
      border-radius: 6px;
      padding: 15px;
      text-align: center;
    }
    .stat-number {
      font-size: 2.5em;
      font-weight: bold;
      color: #9945FF;
      display: block;
    }
    .stat-label {
      font-size: 1.1em;
      color: #666;
    }
    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    .feature-card {
      background-color: rgba(20, 241, 149, 0.06);
      border-left: 4px solid #14F195;
      border-radius: 6px;
      padding: 20px;
    }
    .feature-title {
      font-weight: bold;
      color: #14F195;
      margin-bottom: 10px;
    }
    .comparison-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }
    .comparison-card {
      background-color: rgba(153, 69, 255, 0.04);
      border: 1px solid rgba(153, 69, 255, 0.15);
      border-radius: 6px;
      padding: 20px;
    }
    .comparison-title {
      font-weight: bold;
      font-size: 1.2em;
      margin-bottom: 15px;
      text-align: center;
    }
    .ethereum {
      color: #627EEA;
    }
    .solana {
      color: #9945FF;
    }
    .flow-container {
      margin: 20px 0;
    }
    .flow-step {
      background-color: rgba(153, 69, 255, 0.06);
      border-left: 3px solid #9945FF;
      padding: 15px;
      margin-bottom: 15px;
      border-radius: 6px;
    }
    .step-number {
      background: linear-gradient(135deg, #9945FF 0%, #14F195 100%);
      color: white;
      width: 25px;
      height: 25px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      margin-right: 10px;
      font-size: 0.9em;
    }
    .step-title {
      font-weight: bold;
      color: #9945FF;
      margin-bottom: 8px;
    }

    .code-block {
      background-color: #ffffff;
      color: #1a202c;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', 'Source Code Pro', 'Ubuntu Mono', 'Consolas', monospace;
      font-size: 1.05em;
      font-weight: 600;
      overflow-x: auto;
      white-space: pre;
      line-height: 1.6;
      tab-size: 4;
      -moz-tab-size: 4;
      -webkit-tab-size: 4;
      word-wrap: break-word;
      display: block;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      letter-spacing: 0.025em;
    }
    
    .code-block code {
      background: none;
      padding: 0;
      border: none;
      font-family: inherit;
      font-size: inherit;
      white-space: inherit;
    }
  </style>
</head>
<body>
  <div class="slide slide-title">
    <img src="images/bootcamplogo.png" alt="Solana Bootcamp - The Camp: GROUND">
  </div>

  <div class="slide">
    <h1>SOLANA ARCHITECTURE</h1>
  </div>


  <div class="slide">
    <h2>1단계: 생성 및 서명</h2>
    <h3>Creation & Signing</h3>
    
    
  </div>

  <div class="slide">
    <h2>2단계: JSON-RPC 엔드포인트로 제출</h2>
    <h3>JSON-RPC Endpoint Submission</h3>
    
    <h4>RPC 호출</h4>
    <p>유저의 지갑이 TX를 RPC 노드로 전송합니다.</p>
    
   
    <h4>즉시 로컬 검증</h4>
    <p>RPC 노드가 수신 즉시 다음을 tx 검증 후, EL로 전송</p>
    
  </div>

  <div class="slide">
    <h2>3단계: 노드 내부 멤풀 편입</h2>
    <h3>Local Mempool Insertion</h3>
    
    <p>TX가 멤풀에 존재 </p>
    
  </div>

  <div class="slide">
    <h2>4단계: 멤풀 네트워크 전파</h2>
    <h3>Mempool Network Propagation</h3>
    
    <h4>브로드캐스팅</h4>
    <p>트랜잭션이 EL 가십을 통해 네트워크에 브로드캐스트됩니다.</p>
    
    <h4>전체 네트워크 멤풀 진입</h4>
    <p>승인된 트랜잭션은 각 피어 노드의 멤풀에 들어갑니다.</p>
    
    ----------> slow factor 

  </div>

  <div class="slide">
    <h2>5단계: 후보 블록 조립</h2>
    <h3>Candidate Block Assembly</h3>
    
    <div class="comparison-container">
      <div class="comparison-card">
        <p>검증자가 Block Proposer로 선택되면:</p>
        <ul>
          <li>CL 클라이언트가 EL 클라이언트의 <code>engine_getPayloadV3</code> 호출</li>
          <li>EL이 멤풀에서 트랜잭션을 가져와 실행 페이로드 구성</li>
          <li>EL이 페이로드를 CL에 반환, CL이 블록으로 래핑하고 서명</li>
        </ul>
        </div>
      </div>
      -------------> slow factor 

    </div>

  <div class="slide">
    <h2>6단계: 블록 전파 및 슬롯 증명</h2>
    <h3>Block Propagation & Slot Attestations</h3>
    
    <h4>블록 전파</h4>
    <p>제안자가 서명된 블록을 가십합니다.</p>
    
    <div class="highlight">
      <p><strong>주요 병목:</strong> 네트워크 전파 지연이 발생할 수 있는 구간입니다.</p>
    </div>
    -------------> slow factor 
  </div>

  <div class="slide">
    <h2>7단계: 트랜잭션 실행 및 상태 전이</h2>
    <h3>Transaction Execution & State Transition</h3>
    
    <h4>블록 실행 프로세스</h4>
    <p>EL 클라이언트가 생성된 블록을 받아서 다음을 수행:</p>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">트랜잭션 실행</div>
        <p>EVM 상태 트라이에 대해 트랜잭션들을 실행합니다.</p>
        -------------> slow factor 
      </div>
      <div class="feature-card">
        <div class="feature-title">State Trie 변동</div>
        <p>각 EL의 State Trie를 Tx 실행 결과에 따라 변동시킵니다.</p>
      </div>
    </div>
    
  </div>

  <div class="slide">
    <h2>8단계: 포크 선택</h2>
    <h3>Fork Choice: LMD-GHOST + Casper FFG</h3>
    
    <h4>지속적인 포크 선택</h4>
    <p>모든 노드가 정규 헤드를 선택하기 위해 지속적으로 포크 선택을 실행합니다.</p>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">LMD-GHOST</div>
        <p>가장 많은 증명 가중치를 가진 경로를 따라 체인을 확장합니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">Casper FFG</div>
        <p>체크포인트 기반 최종성 메커니즘을 제공합니다.</p>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>9단계: 최종성과 비가역성</h2>
    <h3>Finality → Irreversibility</h3>
    
    <h4>최종성 달성</h4>
    <ul>
      <li>에포크 N에서 ⅔ 이상의 스테이크가 체크포인트에 증명 → <strong>정당화</strong></li>
      <li>에포크 N+1에서 이전 정당화된 체크포인트가 같은 상태 달성 → <strong>최종화</strong></li>
    </ul>
    
    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-number">2 에포크</span>
        <div class="stat-label">일반적인 최종성 시간 (≈ 12.8분)</div>
      </div>
  </div>
    
    <div class="highlight">
      <p><strong>주요 병목:</strong> 12.8분의 긴 최종성 시간이 이더리움의 주요 성능 제약입니다.</p>
    </div>
    -------------> slow factor 
    
    <div class="highlight">
      <p><strong>핵심:</strong> 이더리움의 경제적 최종성은 매우 강력하지만, 달성하는 데 상당한 시간이 소요됩니다.</p>
    </div>
  </div>

  


  <div class="slide">
    <h2>High Level Overview</h2>
    <p>솔라나는 사용자 지갑에서 시작된 트랜잭션이 Gulfstream을 거쳐 블록에 포함되고, Turbine 프로토콜을 통해 전파된 후 합의에 이르는 아키텍처를 가지고 있습니다.</p>
    
    <div class="diagram">
      <img src="images/HighLevelOverview.png" alt="Solana Transaction Flow Diagram">
    </div>
    
    <div class="highlight">
      <p><strong>핵심 특징:</strong></p>
      <ul>
        <li>멤풀 없는 아키텍처 - 트랜잭션이 대기하지 않고 직접 리더에게 전달</li>
        <li>PoH 기반 시간 동기화 - 글로벌 시계 역할로 합의 효율성 극대화</li>
        <li>병렬 트랜잭션 처리 - 계정 충돌 사전 검사로 동시 실행 가능</li>
        <li>효율적인 블록 전파 시스템 - Turbine 프로토콜로 O(log N) 전파</li>
        <li>연속적 블록 생성 - 400ms 슬롯마다 실시간 블록 생성</li>
      </ul>
    </div>
    
    <p><strong>성능 우위:</strong> 이러한 혁신적 설계로 솔라나는 초당 65,000+ 트랜잭션 처리, $0.00025 평균 수수료, 400ms 블록 시간을 달성하며 블록체인 트릴레마(확장성, 보안성, 탈중앙화)를 동시에 해결합니다.</p>
  </div>

  <div class="slide">
    <h2>The Scalability Challenge</h2>
    <h3>Why Blockchain Needs to Scale</h3>
    <p>확장성은 블록체인 업계의 지속적인 도전과제입니다. 탈중앙화 금융의 폭발적인 성장과 함께 블록체인의 확장성 수요가 증가하고 있습니다.</p>
    
    <div class="comparison-container">
      <div class="comparison-card">
        <div class="comparison-title solana">🟣 솔라나의 접근법</div>
        <ul>
          <li><strong>레이어1 직접 최적화:</strong> 복잡한 레이어링 없이 기본 체인 성능 향상</li>
          <li><strong>높은 하드웨어 스펙 활용</strong></li>
          <li><strong>비동기 처리:</strong> 모든 검증과 처리를 비동기 상태로 수행</li>
          <li><strong>빠른 Propagation:</strong> Gulfstream 통해 빠르게 전파</li>
        </ul>
      </div>
    </div>
    
  
  </div>

  <div class="slide">
    <h2>The Basics: Core Components of Solana</h2>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">Leader</div>
        <p>특정 시간(슬롯) 동안 블록을 생성할 책임이 있는 검증자(Validator). 약 1.6초(4 슬롯) 동안 연속으로 블록을 생성합니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">Transaction</div>
        <p>솔라나 블록체인의 상태를 변경하기 위한 서명된 지시사항들의 묶음. 모든 계정을 미리 명시하여 병렬 처리가 가능합니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">Proof of History (PoH)</div>
        <p>트랜잭션의 순서를 암호학적으로 증명하여 노드 간 합의를 빠르게 만드는 글로벌 시계 역할을 하는 기술입니다.</p>

      </div>
    </div>

    
  </div>

  <div class="slide">
    <h2>솔라나 리더(Leader)란?</h2>
    <h3>네트워크의 심장: 블록 생성 책임자</h3>
    
    <div class="diagram">
      <img src="images/Leader.png" alt="Solana Leader">
    </div>
    
    <p>솔라나 네트워크에서 <strong>리더</strong>는 특정 시간 구간(<em>슬롯</em>) 동안 블록을 생성하고 네트워크에 전파하도록 지정된 검증자(Validator)입니다.</p>
    
    <div class="highlight">
      <p><strong>핵심 차이점:</strong> 이더리움·비트코인과 달리 솔라나는 <em>미리 계산된 리더 스케줄</em>을 사용해 끊김 없는 블록 생산을 보장하며, 하나의 리더가 약 1.6초(4 슬롯) 동안 연속으로 블록을 생성합니다.</p>
    </div>
    
    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-number">1.6초</span>
        <div class="stat-label">연속 리더 시간 (4 슬롯)</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">400ms</span>
        <div class="stat-label">슬롯 시간 간격</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">2-3일</span>
        <div class="stat-label">에포크 주기</div>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>리더의 핵심 업무 4단계</h2>
    <h3>초단위로 반복되는 블록 생성 과정</h3>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">트랜잭션 수집</div>
        <p>리더 슬롯이 시작되면, 클라이언트와 다른 노드들이 전송한 트랜잭션을 <em>Gulf Stream</em> 메커니즘으로 앞당겨 전달받아 메모리 큐에 정렬합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">PoH(Proof-of-History) 진행</div>
        <p>리더는 약 400ms마다 '틱(Tick)' 해시를 생성해 시간 순서를 증명하며, 일부 틱에 트랜잭션 배치를 삽입합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">병렬 실행 & 상태 업데이트</div>
        <p>런타임에서 활용해 병렬로 트랜잭션을 실행, 수수료 징수·계정 상태 변경·루트 해시 계산을 마칩니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">4</span>
        <div class="step-title">블록(→ 슈레드) 생성 & 전파</div>
        <p>실행 결과를 포함한 블록을 128 KB 단위 <em>슈레드(Shred)</em>로 분할하고, <em>Turbine</em> 트리 네트워크를 통해 O(log N) Hop으로 전체 노드에 배포합니다.</p>
      </div>
    </div>
    
    <div class="highlight">
      <p><strong>TLDR:</strong> 리더는 <em>트랜잭션 수집 → PoH → 병렬 실행 → 슈레드 전파</em>를 초단위로 반복해, 솔라나가 수천 TPS를 유지하도록 만드는 네트워크의 "심장"입니다.</p>
      <p>검증자들은 선정된 리더에게 트랜잭션을 보내고, 리더는 받은 트랜잭션을 바탕으로 블록을 생성합니다. 블록을 생성하면서 동시에 PoH 해시를 돌려 솔라나의 트랜잭션 순서까지 결정하는 것을 알 수 있습니다.</p>
    </div>
  </div>

  <div class="slide">
    <h2>어떻게 리더가 선출되나?</h2>
    <h3>사전 예측 가능한 스케줄링</h3>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">에포크별 계산</div>
        <p>매 <strong>에포크</strong>(약 2-3일)마다 네트워크 스냅샷을 기준으로 <em>지분 증명(PoS)</em> 가중 라운드로빈 방식으로 리더 순서표가 계산됩니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">사전 예측</div>
        <p>모든 노드는 "슬롯 → 리더" 매핑을 미리 알고 있어, 자신의 리더 슬롯이 오기 전에 하드웨어·네트워크 준비를 완료할 수 있습니다.</p>
      </div>
    </div>
    
    <div class="highlight">
      <p><strong>사전 예측의 장점:</strong> 트랜잭션은 "미래 리더"에게 바로 전달되므로, 줄 서기 지연이 크게 줄어들고 처리량(TPS)이 높아집니다.</p>
    </div>
    
    <h4>보상과 페널티</h4>
    <ul>
      <li><strong>보상:</strong> 리더가 수집한 수수료 (MEV) + 인플레이션 보상을 받습니다.</li>
      <li><strong>실패 시:</strong> 슬롯 내에 블록을 못 만들면 해당 슬롯은 '스킵', 반복되면 페널티(잠재적 슬래싱) 위험이 있습니다.</li>
      <li><strong>경제성:</strong> 리더 역할을 제대로 수행하지 못하면 보상을 잃게 되므로, 검증자들은 정직하게 행동할 경제적 유인이 있습니다.</li>
    </ul>
  </div>







  <div class="slide">
    <h2>Proof of History (PoH)</h2>

    <p>솔라나는 총 처리량(단위 시간당 처리되는 트랜잭션 수)과 지연시간(트랜잭션 제출부터 확인까지 걸리는 시간) 모든 면에서 빠르기를 목표로 합니다. POS만으로도 정직한 노드들과의 합의를 보장할 수 있지만, PoH는 이를 강화하여 보안을 유지하면서도 가장 빠른 PoS 네트워크를 달성합니다.</p>
    
    <div class="diagram">
      <img src="images/POH.png" alt="Solana PoH">
    </div>
    
    <h3>The Clock Synchronization Problem</h3>
    <p>리더 스케줄이 설정되었지만 문제가 남아있습니다: 리더들이 순서를 벗어나 블록을 방출하는 것을 어떻게 방지할까요?</p>
    
    <div class="comparison-container">
      <div class="comparison-card">
        <div class="comparison-title" style="color: #FF6B6B;">🔴 이더리움의 시간 </div>
        <ul>
          <li><strong>NTP Server + Local OS time</strong> 사용</li>
          <li>정확한 기준이 없음</li>
      
          <li> 이렇게 하는것이 가능한 이유 =  12초 블록 시간으로 여유 있음</li>
          <li>노드 간 시간 차이 허용 가능</li>
        </ul>
      </div>
      <div class="comparison-card">
        <div class="comparison-title" style="color: #9945FF;">🟣 솔라나의 시간 </div>
        <ul>
          <li><strong>400ms</strong>의 매우 짧은 블록 시간</li>
          <li>리더 스케줄: A → C → B</li>
          <li>동시 블록 생성 위험성 높음</li>
          <li>정밀한 시간 동기화 필수</li>
        </ul>
      </div>

      
    </div>
    
    <div class="highlight">
      <p><strong>핵심 문제:</strong> 솔라나는 400ms라는 매우 짧은 블록타임을 가지고 있기 때문에, 예를 들어 리더 스케줄이 A → C → B로 나와 있다고 할 때 서로 블록을 동시에 생성하는 일이 발생할 수 있습니다. 기존 방식처럼 NTP나 로컬 OS 시간에 의존하면 부정확한 동기화로 인한 충돌이 빈번히 발생합니다.</p>
    </div>
    
    <h3>The Proof of History Solution</h3>
    <p>PoH는 이 문제에 대한 솔라나의 해결책입니다. 인간 시간척도나 "벽시계 시간" 대신, 반복적인 SHA-256 해시 함수를 특정 횟수만큼 실행하는 데 걸리는 시간을 기반으로 한 "시계"를 사용합니다.</p>
    
    <div class="highlight">
      <p><strong>핵심 전제:</strong> 현재 컴퓨터가 아무리 성능이 좋아져도 해시를 일정시간 이상으로 빠르게 돌릴 수 없다는 물리적 한계가 존재합니다. 이는 PoH가 작동할 수 있는 기반이 됩니다.</p>
    </div>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">각 검증자의 틱 생성</div>
        <p>각 밸리데이터들이 각자 tick을 계속 돌립니다. 리더 스케줄이 나왔을 때 각 밸리데이터들은 틱을 돌려서 자신의 리더 차례가 오기까지 얼만큼의 시간이 지났는지를 판단합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">SHA-256 기반 시계</div>
        <p>컴퓨터들은 이미 일반적으로 달성 가능한 "가장 빠른 SHA-256 해시 구현"에 수렴했습니다. 가장 빠른 프로세서를 사용하는 모든 컴퓨터는 초당 특정 횟수의 SHA-256 해시만 계산할 수 있습니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">틱(Tick) 측정</div>
        <p>솔라나는 인간 척도가 아닌 초당 반복적인 SHA-256 해시 횟수로 시간을 측정합니다. 실제로는 초의 작은 부분을 근사하는 SHA-256 해시 반복 횟수인 "틱"이라는 단위로 측정합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">4</span>
        <div class="step-title">시간 증명</div>
        <p>초기 값과 100만 번의 SHA-256 반복 후 계산된 값을 제공함으로써, 검증자는 반복적인 SHA-256 해시 함수를 실행하는 데 약 1초의 시간을 소비했음을 증명할 수 있습니다.</p>
      </div>
    </div>
    
    <div class="highlight">
      <p><strong>자신의 차례 판단:</strong> 자신의 차례가 되면 검증자는 틱 계산을 통해 정확한 타이밍을 알 수 있고, 다른 검증자들과 동시에 블록을 생성하는 충돌을 방지할 수 있습니다.</p>
    </div>
    
    <div class="diagram">
        <img src="images/pohcode.png" alt="Solana Leader">
    </div>

    <h3>Block Streaming with PoH</h3>
    <p>솔라나에서 블록은 리더가 트랜잭션을 검증하면서 "스트리밍"됩니다. 제안된 트랜잭션 블록을 전송하는 시간이 실제로 트랜잭션을 검증하는 시간과 겹쳐서, 솔라나의 낮은 지연시간에 기여하는 강력한 파이프라이닝 형태가 됩니다.</p>
    
    <div class="comparison-container">
      <div class="comparison-card">
        <div class="comparison-title" style="color: #FF6B6B;">🔴 전통적 방식</div>
        <ul>
          <li>블록 완성 후 전체 전송</li>
          <li>순차적 검증 과정</li>
          <li>시간 동기화 복잡성</li>
          <li>포크 해결 비용 증가</li>
        </ul>
      </div>
      <div class="comparison-card">
        <div class="comparison-title" style="color: #9945FF;">🟣 PoH 방식</div>
        <ul>
          <li>블록 스트리밍과 검증 동시 진행</li>
          <li>SHA-256 기반 시간 증명</li>
          <li>암호학적 시간 순서 보장</li>
          <li>검열 저항성 확보</li>
        </ul>
      </div>
    </div>

    <h3>Censorship Resistance Example</h3>

    <div class="diagram">
        <img src="images/hashprob.png" alt="Solana Leader">
    </div>

    <p>세 명의 리더 A, B, C가 있고 리더 스케줄이 A - B - C라고 가정해 봅시다. A가 블록을 방출한 후 B의 차례인데, C가 "부정행위"를 시도하여 B의 차례 동안 자신의 블록을 방출하려고 한다면 어떻게 될까요?</p>
    

    <h3>Conclusion</h3>
    <div class="highlight">
      <p><strong>요약:</strong> 솔라나는 스테이크 가중 노드의 투표력을 사용하여 트랜잭션에 대한 합의를 달성하는 Proof of Stake 네트워크입니다. 네트워크의 속도는 리더 스케줄에 내장된 자연스러운 포크 회피 메커니즘을 통해 향상되며, 리더 스케줄이 준수되면서 높은 속도와 낮은 지연시간을 유지하도록 보장하는 PoH 메커니즘을 통해 더욱 향상됩니다.</p>
    </div>
    
    <p>PoH는 PBFT 대비 시간 증명에 대한 합의 과정을 생략시키고, 통신 오버헤드를 극적으로 줄여 솔라나가 높은 TPS를 달성하는 핵심적인 역할을 합니다. 이는 검열 저항적이며 1/3 이상의 정직한 노드가 있는 한 안정적으로 작동하는 것으로 입증된 시스템입니다.</p>
  </div>

  <div class="slide">
    <h2>Transaction Structure</h2>
    <h3>Anatomy of a Solana Transaction</h3>
    
    <div class="diagram">
      <img src="images/Transaction.png" alt="Solana Transaction">
    </div>
    
    <p>트랜잭션은 솔라나 블록체인의 상태를 변경하기 위한 서명된 지시사항들의 묶음입니다. 단순한 토큰 전송부터 복잡한 스마트 컨트랙트 실행까지 모든 활동은 트랜잭션을 통해 이루어집니다.</p>
    
    <ul>
      <li><strong>헤더 (Header):</strong> 트랜잭션에 서명해야 하는 계정 주소 목록에 대한 참조를 포함합니다. 서명이 필요한 계정과 읽기 전용 계정을 구분합니다.</li>
      <li><strong>계정 주소 목록 (Account Addresses):</strong> 트랜잭션 동안 읽거나 쓸 모든 계정 목록입니다. 이 목록을 사전에 명시하는 것은 솔라나의 핵심적인 특징으로, 이를 통해 병렬 처리가 가능해집니다.</li>
      <li><strong>최근 블록해시 (Recent Blockhash):</strong> 중복되거나 오래된 트랜잭션을 방지하는 데 사용됩니다. 약 1분(150 슬롯) 후에 만료되어 처리되지 않은 트랜잭션이 계속 떠도는 것을 방지합니다.</li>
      <li><strong>명령어 (Instructions):</strong> 트랜잭션의 핵심 로직입니다. 전송, 발행, 소각 등 특정 작업을 나타내며, 실행할 프로그램, 계정, 데이터 등을 지정합니다.</li>
    </ul>
    
    <div class="highlight">
      <p><strong>병렬 처리의 비밀:</strong> 솔라나는 트랜잭션마다 참조될 모든 계정을 데이터 안에 미리 포함합니다. 덕분에 노드는 실행 전에 관련 계정을 한눈에 파악할 수 있고, 사용자는 트랜잭션을 보낼 때 필요한 계정을 모두 지정해야 합니다. 이 설계 철학은 솔라나 프로그램(스마트 컨트랙트)을 작성할 때 특히 두드러지며, 계정 충돌을 사전에 제거해 병렬 처리가 극대화되면서 압도적인 TPS를 달성할 수 있습니다.</p>
    </div>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">개발자 워크플로우</div>
        <p>솔라나 프로그램을 작성할 때, 개발자는 1) Instruction을 호출하는 트랜잭션에 필요한 모든 계정을 지정하고, 2) 그 계정들을 대상으로 원하는 로직을 실행하는 Instruction(명령)을 정의하는 흐름을 따릅니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">수수료 구조</div>
        <p>총 수수료 = 우선순위 수수료 + 기본 수수료. 기본 수수료는 서명당 5,000 램포트이며, 우선순위 수수료는 컴퓨팅 유닛 가격 × 컴퓨팅 유닛 한도로 계산됩니다.</p>
      </div>
    </div>
  </div>



  <div class="slide">
    <h2>QUIC Protocol</h2>
    <h3>UDP-Based High-Performance Networking</h3>
    
    <p>2022년 말 솔라나에서 리더 교체 트랜잭션 관리를 위해 적용한 UDP 기반의 네트워킹 프로토콜입니다. 구글에서 주도적으로 개발하다 현재는 IETF 표준화가 진행되고 있습니다.</p>
    
    <div class="highlight">
      <p><strong>솔라나에서 QUIC 사용 이유:</strong> 솔라나의 빠른 블록 생성 간격(400ms)과 빈번한 리더 교체에서 모든 검증자가 새 리더와 빠른 연결을 맺어야 하므로, QUIC의 저지연 특성이 핵심적입니다. 기존 TCP로는 혼잡 제어와 순차적 패킷 전송으로 인한 병목이 발생하지만, QUIC은 이를 해결합니다.</p>
    </div>
  </div>


  <div class="slide">
    <h2>Transaction Lifetime: Complete Journey</h2>
    <h3>10 Critical Steps</h3>
    
    <p>사용자 지갑에서 시작된 트랜잭션이 최종 합의에 이르기까지의 전체 여정을 살펴보겠습니다.</p>
    
    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-number">1-3</span>
        <div class="stat-label">Transaction Submission & Gulfstream</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">4-5</span>
        <div class="stat-label">Leader Processing & Block Building</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">6-8</span>
        <div class="stat-label">Turbine Propagation & TVU</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">9-10</span>
        <div class="stat-label">Consensus & Finalization</div>
      </div>
    </div>
  </div>

  <div class="slide">
    <h3>Transaction Lifecycle: Steps 1-5</h3>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">트랜잭션 송신</div>
        <p>클라이언트가 RPC 프로바이더로 트랜잭션을 전송합니다. RPC 프로바이더는 트랜잭션을 RPC 노드에게 전달합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">걸프스트림(Gulfstream)</div>
        <p>RPC 노드가 벨리데이터에게 혹은 직접 트랜잭션을 전달합니다. 멤풀 없이 트랜잭션을 효율적으로 선-전송하여 처리 대기 시간을 최소화합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">리더 처리</div>
        <p>현재 슬롯의 리더는 PoH 시퀀스에서 트랜잭션의 순서를 확인하고, 트랜잭션의 유효성을 검증한 후, 상태(State)를 업데이트합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">4</span>
        <div class="step-title">블록 완성 & 전파 준비</div>
        <p>Bank 업데이트가 완료되면, 리더는 완성된 블록 + PoH 해시를 다른 검증자에게 전파합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">5</span>
        <div class="step-title">터빈(Turbine) 프로토콜</div>
        <p>Turbine은 블록 데이터를 여러 Shred로 분할하며, Shred마다 루트 노드를 돌려가며 병렬 전송합니다(트리 방식).</p>
      </div>
    </div>
  </div>

  <div class="slide">
    <h3>Transaction Lifecycle: Steps 6-10</h3>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">6</span>
        <div class="step-title">검증자 수신</div>
        <p>검증자들이 블록 Shred를 수신하고, PoH 해시를 받아 자체 PoH를 업데이트합니다. 받은 Shred를 자신의 Turbine 하위 노드로 재전송합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">7</span>
        <div class="step-title">TVU(Transaction Validation Unit)</div>
        <p>모든 Shred 검증이 완료되면 로컬 Bank를 업데이트합니다. 전체 과정은 TVU 모듈 내부에서 동작합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">8</span>
        <div class="step-title">Replay Stage (TVU 핵심)</div>
        <p>Replay Stage에서 대부분의 핵심 로직이 실행됩니다: 블록 투표(voting), PoH reset, Bank(state) 변경 반영, 차기 리더 전환</p>
      </div>
      <div class="flow-step">
        <span class="step-number">9</span>
        <div class="step-title">PBFT 스타일 합의</div>
        <p>Solana는 PBFT 기반 합의를 수행하되, PoH clock 덕분에 노드 간 통신을 최소화하면서 투표가 가능합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">10</span>
        <div class="step-title">체인 품질 보장</div>
        <p>슬롯마다 단 하나의 리더만 블록을 제안할 수 있으며, 전 노드가 PoH로 시간 동기화하여 포크 확률을 감소시킵니다.</p>
      </div>
    </div>
</div> 

  
  <div class="slide">
    <h2>Gulf Stream: Transaction Forwarding Protocol</h2>
    <h3>Mempool-less Transaction Processing</h3>
    
    <div class="diagram">
      <img src="images/gossipVleader.png" alt="Gulfstream Architecture">
    </div>
    
    <p><strong>정의:</strong> Gulf Stream은 네트워크 노드가 트랜잭션을 수신한 순간부터 현재 슬롯의 리더에게 전달되어 TPU의 Fetch Stage에서 받아들여지기까지의 전체 과정입니다.</p>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">RPC 노드 수신</div>
        <p>User → RPC Node로 HTTP를 통해 트랜잭션 전송. RPC는 게이트웨이 역할을 하며 unstaked이므로 합의에 참여하지 않음.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">QUIC 변환 및 리더 조회</div>
        <p>RPC가 HTTP를 QUIC로 변환하고, 리더 스케줄을 조회하여 현재 및 다음 리더의 주소와 포트 정보를 확인.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">리더 직접 전달</div>
        <p>결정론적으로 정해진 리더에게 직접 전달. 가십 네트워크가 아닌 point-to-point 전송으로 효율성 극대화.</p>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>Recent Blockhash & Transaction Lifecycle</h2>
    <h3>Automatic Transaction Expiration</h3>

    <div class="highlight">
      <p><strong>핵심 메커니즘:</strong> 모든 솔라나 트랜잭션은 Recent Blockhash를 포함해야 하며, 150 슬롯 후 자동 만료됩니다. 이는 중복 트랜잭션 방지와 네트워크 정리를 동시에 수행합니다.</p>
    </div>
    
    <div class="comparison-container">
      <div class="comparison-card">
        <div class="comparison-title" style="color: #FF6B6B;">🔴 기존 Mempool 방식</div>
        <ul>
          <li>트랜잭션이 무기한 대기 가능</li>
          <li>낮은 수수료 시 며칠-몇 주 지연</li>
          <li>nonce 기반 중복 방지</li>
          <li>가십으로 전체 네트워크 전파</li>
    </ul>
      </div>
      <div class="comparison-card">
        <div class="comparison-title solana">🟣 솔라나 Gulf Stream</div>
        <ul>
          <li>Recent Blockhash로 1분 내 자동 만료</li>
          <li>mempool 없이 즉시 처리 또는 제거</li>
          <li>blockhash 기반 중복 방지</li>
          <li>리더에게 직접 전달</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>Stake-weighted Quality of Service (SWQoS)</h2>
    <h3>Preventing Spam and Sybil Resistance</h3>
    
    <p><strong>SWQoS는 2024년 초 도입된 메커니즘으로</strong>, 리더가 staked validators를 통해 라우팅된 트랜잭션 메시지를 우선순위로 처리할 수 있게 합니다. 높은 스테이크를 가진 검증자일수록 리더에게 트랜잭션 메시지 패킷을 전송할 수 있는 용량이 비례적으로 증가합니다.</p>
    
    밸리데이터들은 자신의 스테이크 비율에 따라 리더에게 보낼수 있는 트랜잭션 bandwidth를 결정합니다. 

    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-number">80%</span>
        <div class="stat-label">Staked peers 전용 (2,000 연결)</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">20%</span>
        <div class="stat-label">Non-staked nodes (500 연결)</div>
      </div>
    </div>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">Sybil 공격 방지</div>
        <p>IP 주소를 통해 검증 가능한 QUIC 연결로 낮은 스테이크나 non-staked 노드들의 공격을 효과적으로 차단합니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">Priority Lane 시스템</div>
        <p>고속도로의 유료 우선차선과 유사한 구조로, RPC 노드들이 validator의 stake-weighted 용량을 임대할 수 있습니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">트랜잭션 포함률 향상</div>
        <p>RPC 노드가 더 높은 대역폭을 확보하여 블록에 포함될 트랜잭션 비율을 크게 증가시킬 수 있습니다.</p>
      </div>

    </div>
    
    <div class="highlight">
      <p><strong>생태계 영향:</strong> SWQoS는 트랜잭션을 리더에게 전달하는 요구사항을 높이고 스팸 공격의 효과를 크게 감소시켰습니다. 이로 인해 높은 트래픽을 처리하는 애플리케이션들은 자체 검증자 노드를 운영하여 수직 통합하는 방향으로 발전하고 있습니다.</p>
    </div>
    
    <div class="diagram">
      <img src="images/SWQOS.png" alt="Stake-Weighted QoS">
    </div>
  </div>

  <div class="slide">
    <h2>Block Building: Continuous vs Discrete</h2>
    <h3>Real-time Block Assembly</h3>
    
    <div class="comparison-container">
      <div class="comparison-card">
        <div class="comparison-title" style="color: #FF6B6B;">🔴 Discrete Block Building</div>
        <ul>
          <li>전체 블록 완성 후 브로드캐스트</li>
          <li>블록 조립 완료까지 대기</li>
          <li>순차적 처리로 지연 발생</li>
          <li>네트워크 부하 집중</li>
        </ul>
      </div>
      <div class="comparison-card">
        <div class="comparison-title solana">🟣 Solana Continuous Building</div>
        <ul>
          <li>할당된 시간 동안 동적 조립 및 스트리밍</li>
          <li>실시간 블록 생성 및 전파</li>
          <li>지연 시간 대폭 단축</li>
          <li>효율적인 네트워크 활용</li>
        </ul>
      </div>
    </div>
    
    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-number">400ms</span>
        <div class="stat-label">각 슬롯 지속 시간</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">4 슬롯</span>
        <div class="stat-label">연속 리더 할당 (1.6초)</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">2 슬롯 전</span>
        <div class="stat-label">리더 준비 시작</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">1GB/s+</span>
        <div class="stat-label">리더 전환 시 트래픽 급증</div>
      </div>
    </div>
    
    <div class="highlight">
      <p><strong>리더 준비 과정:</strong> 리더가 되기 2슬롯 전에 트랜잭션 전달을 중단하고 준비합니다. 이 기간 동안 전체 네트워크가 곧 리더가 될 노드에게 패킷을 집중 전송하여 기가바이트/초 수준의 트래픽 폭증이 발생합니다.</p>
    </div>
  </div>

  <div class="slide">
    <h2>Transaction Processing Unit (TPU)</h2>
    <h3>Core Block Production Logic</h3>
    
    <div class="diagram">
      <img src="images/TPU.png" alt="TPU Architecture">
    </div>
    
    <p>트랜잭션 메시지가 도착하면 Transaction Processing Unit(TPU)로 진입합니다. TPU는 블록 생성을 담당하는 검증자의 핵심 로직입니다.</p>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">Fetch Stage</div>
        <p>QUIC을 통해 트랜잭션을 수신하는 첫 번째 단계입니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">SigVerify Stage</div>
        <p>서명 유효성 검증, 올바른 서명 수 확인, 중복 트랜잭션 제거 등 엄격한 검증을 수행합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">Banking Stage</div>
        <p>실제 블록 구축 단계로, TPU의 가장 중요한 부분입니다. 병렬 처리와 상태 업데이트를 담당합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">4</span>
        <div class="step-title">PoH Service</div>
        <p>엔트리 해시를 Proof of History 서비스로 전송하여 시간 순서를 기록합니다.</p>
      </div>
    </div>
    
    <div class="highlight">
      <p><strong>핵심 원칙:</strong> 블록이 승인되려면 모든 트랜잭션이 유효하고 다른 노드들에 의해 재현 가능해야 합니다.</p>
    </div>
  </div>

  <div class="slide">
    <h2>Banking Stage: Parallel Processing Engine</h2>
    <h3>The Heart of Solana's Performance</h3>
    
    <p><strong>Bank 정의:</strong> Bank는 현재 슬롯의 월드-스테이트 를 담고있는 임시 메모리 공간입니다. 충분한 검증자가 투표한 후 블록이 최종화되면, bank의 계정 업데이트를 디스크에 플러시하여 영구적으로 만듭니다. 체인의 최종 상태는 모든 확정된 트랜잭션의 결과이며, 이 상태는 블록체인 히스토리에서 항상 결정론적으로 재생성할 수 있습니다.</p>
    
    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-number">6</span>
        <div class="stat-label">총 처리 스레드</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">4</span>
        <div class="stat-label">일반 트랜잭션 스레드</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">2</span>
        <div class="stat-label">투표 전용 스레드</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">64</span>
        <div class="stat-label">엔트리당 최대 트랜잭션</div>
      </div>
    </div>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">트랜잭션 충돌 규칙</div>
        <ul>
          <li><strong>두 번의 쓰기:</strong> 두 트랜잭션이 모두 같은 계정에 쓰기 시도</li>
          <li><strong>읽기 + 쓰기:</strong> 하나는 읽기, 다른 하나는 쓰기 시도</li>
          <li><strong>해결책:</strong> 충돌하는 트랜잭션은 다른 엔트리에 배치하여 순차 실행</li>
        </ul>
      </div>
      
    </div>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">엔트리로 그룹화</div>
        <p>confict가 없는 트랜잭션 64개를 "엔트리"로 패키징.</p>
        <p>Tx에는 각 tx가 읽고 쓸 계정들의 목록이 들어있기 때문에 그룹화 용이함.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">계정 락킹</div>
        <p>트랜잭션 실행에 필요한 계정들을 잠금. 사전 명시된 계정 목록으로 Race condition 방지.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">유효성 검증</div>
        <p>트랜잭션이 최신이지만 중복 처리되지 않았는지 확인. Recent Blockhash 검증 포함.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">4</span>
        <div class="step-title">SVM 실행</div>
        <p>계정 로드 후 트랜잭션 로직 실행, 계정 상태 업데이트. rBPF 기반 eBPF 프로그램의 JIT 컴파일.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">5</span>
        <div class="step-title">PoH 기록 & 커밋</div>
        <p>엔트리 해시를 PoH 서비스로 전송. 성공 시 모든 변경사항을 bank에 커밋하고 계정 락 해제.</p>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>Transaction Ordering Flexibility</h2>
    <h3>Design Philosophy & Economic Implications</h3>
    
    <div class="highlight">
      <p><strong>핵심 설계 원칙:</strong> 솔라나 프로토콜은 트랜잭션 검증에 대해서는 매우 엄격한 규칙을 가지고 있지만, 리더가 블록 내에서 트랜잭션을 실행해야 하는 특정 순서는 강제하지 않습니다.</p>
    </div>
    
    <div class="comparison-container">
      <div class="comparison-card">
        <div class="comparison-title" style="color: #FF6B6B;">유연한 순서 결정</div>
        <ul>
          <li><strong>리더 재량:</strong> 블록 내 트랜잭션 순서 자유 결정</li>
          <li><strong>MEV 기회:</strong> Maximum Extractable Value 최적화</li>
          <li><strong>수수료 우선순위:</strong> 높은 수수료 트랜잭션 우선 처리</li>
        </ul>
      </div>
    </div>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">Jito & 블록 빌딩 마켓</div>
        <ul>
          <li><strong>Jito:</strong> 검증자와 거래자 간 MEV 수익 공유 플랫폼</li>
          <li><strong>번들링:</strong> 복잡한 트랜잭션 그룹을 하나로 묶어 처리</li>
          <li><strong>경매 시스템:</strong> 블록 공간에 대한 경쟁적 입찰</li>
        </ul>
      </div>
    </div>
    
  </div>

  <div class="slide">
    <h2>Turbine: 솔라나의 핵심 혁신</h2>
    <h3>BitTorrent에서 영감받은 블록 전파 시스템</h3>
    
    <div class="highlight">
      <p><strong>Mert Mumtaz (Helius CEO):</strong> "The most interesting part about Solana is not parallelization, the SVM, or Toly's tweets. It is something you probably haven't heard of: Turbine."</p>
    </div>
    
    <p>Banking 단계에서 트랜잭션이 엔트리로 조직되어 타임스탬핑을 위해 Proof of History 스트림에 전송됩니다. 블록의 Bank가 업데이트되면, 조직된 엔트리들이 다음 단계인 <strong>Turbine</strong>을 위해 준비됩니다.</p>
    
    <p>Turbine은 리더가 자신의 블록을 네트워크의 나머지 부분에 전파하는 과정입니다. BitTorrent에서 영감을 받아 빠르고 효율적으로 설계되어, 통신 오버헤드를 줄이고 리더가 전송해야 하는 데이터 양을 최소화합니다.</p>
    
    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-number">1,280</span>
        <div class="stat-label">Shred 최대 크기 (바이트)</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">64</span>
        <div class="stat-label">FEC 배치당 Shreds 수</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">32 + 32</span>
        <div class="stat-label">데이터 Shreds + 복구 Shreds</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">200</span>
        <div class="stat-label">실제 팬아웃 값</div>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>Shredding Process: 데이터 분해와 복구</h2>
    <h3>Forward Error Correction을 통한 내결함성</h3>
    
    <div class="diagram">
      <img src="images/shred.png" alt="Shred Structure">
    </div>
    
    <p>Turbine은 트랜잭션 데이터를 <strong>"Shreds"</strong>로 분해하는 <strong>"Shredding"</strong> 과정을 통해 이를 달성합니다. Shreds는 최대 1280바이트의 작은 데이터 패킷으로, 비디오 스트림의 개별 프레임과 유사합니다. 재조립되면 이러한 Shreds를 통해 검증자들이 전체 블록을 재생할 수 있습니다.</p>
    
    <p>Shreds는 UDP를 사용하여 인터넷을 통해 검증자들 사이에서 전송되며, 패킷 손실이나 악의적인 패킷 삭제를 처리하기 위해 <strong>소거 코딩(Erasure Coding)</strong>을 활용합니다. 소거 코딩은 다항식 기반의 오류 검출 및 수정 방식으로 데이터 무결성을 보장합니다. 일부 Shreds가 손실되더라도 블록은 여전히 재구성될 수 있습니다.</p>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">FEC 배치 (Forward Error Correction)</div>
        <ul>
          <li><strong>구성:</strong> 기본적으로 64개 Shreds (32개 데이터 + 32개 복구)</li>
          <li><strong>복구 수준:</strong> 배치 내 최대 50% 패킷 손실/손상까지 복구 가능</li>
          <li><strong>배치별 복구:</strong> 데이터 복구는 FEC 배치별로 이루어짐</li>
        </ul>
      </div>
      <div class="feature-card">
        <div class="feature-title">머클화 및 체인 연결</div>
        <ul>
          <li><strong>배치 머클화:</strong> 각 64 Shreds 배치가 머클화됨</li>
          <li><strong>리더 서명:</strong> 루트는 리더에 의해 서명되고 이전 배치에 연결</li>
          <li><strong>검증 경로:</strong> 머클 루트 체인이 진위성과 무결성의 검증 가능한 경로 제공</li>
        </ul>
      </div>
    </div>
    
    <div class="highlight">
      <p><strong>보안 보장:</strong> 이 과정은 네트워크 내의 어떤 노드에서든 Shreds를 안전하게 획득할 수 있도록 보장하며, 머클 루트의 체인은 진위와 무결성을 검증할 수 있게 합니다.</p>
    </div>
  </div>

  <div class="slide">
    <h2>Turbine Tree: 계층적 전파 아키텍처</h2>
    <h3>Outbound Data Egress Pressure 완화</h3>

    <div class="diagram">
        <img src="images/turbine.png" alt="Shred Structure">
    </div>
    
    <p>리더는 처음에 단일 루트 노드로 브로드캐스팅하며, 이 루트 노드가 Shreds를 모든 다른 검증자 노드에 전파합니다. <strong>이 루트 노드는 각 Shred마다 변경됩니다.</strong> 검증자들은 층(Layer)으로 조직되어 "Turbine Tree"를 형성합니다.</p>

    <p> 실제 팬아웃 값 : 200 </p>
    <p> 홉 수 : 2-3 </p>

    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">계층적 배치 전략</div>
        <ul>
          <li><strong>상위층:</strong> 더 큰 지분을 가진 검증자들이 트리 상단에 배치</li>
          <li><strong>하위층:</strong> 더 적은 지분을 가진 검증자들이 트리 하단에 배치</li>
          <li><strong>최적화:</strong> 지분 기반 배치로 네트워크 신뢰성과 효율성 극대화</li>
        </ul>
      </div>
      <div class="feature-card">
        <div class="feature-title">동적 보안 메커니즘</div>
        <ul>
          <li><strong>트리 회전:</strong> 보안상 이유로 각 새로운 Shreds 배치마다 트리 순서 회전</li>
          <li><strong>루트 변경:</strong> 각 Shred마다 다른 루트 노드 사용</li>
          <li><strong>분산 부하:</strong> 송신 및 재송신 시스템으로 부하 분산</li>
        </ul>
      </div>
    </div>
    
    <div class="highlight">
      <p><strong>핵심 목표:</strong> 이러한 시스템의 주요 목표는 <strong>리더와 루트 노드의 outbound data egress pressure를 완화</strong>하는 것입니다. 송신 및 재송신 시스템을 활용함으로써, 부하는 리더와 재송신자들 사이에 분산되어 단일 노드에 가해지는 부담을 줄입니다.</p>
    </div>
  </div>


  <div class="slide">
    <h2>Transaction Validation Unit (TVU)</h2>
    <h3>Block Validation & Consensus</h3>

    <p>검증자가 Turbine을 통해 리더로부터 새로운 블록을 받으면, 각 엔트리 내의 모든 트랜잭션을 검증해야 합니다. 이는 전체 블록을 재생하고, PoH 해시를 병렬로 검증하며, PoH가 지시하는 순서대로 트랜잭션을 재생성하고, 로컬 bank를 업데이트하는 과정을 포함합니다.</p>
    
    <div class="diagram">
      <img src="images/tvu.png" alt="Transaction Validation Unit">
    </div>
    
    <p>이 과정은 <strong>Transaction Validation Unit (TVU)</strong>에서 처리되며, 이는 리더의 Transaction Processing Unit (TPU)과 유사하게 shreds 처리와 블록 검증을 담당하는 핵심 로직 역할을 합니다.</p>
  </div>

  <div class="slide">
    <h2>TVU Pipeline: 4단계 검증 과정</h2>
    <h3>From Shreds to Validated Blocks</h3>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">Shred Fetch Stage</div>
        <p>Turbine을 통해 shreds를 수신하는 첫 번째 단계입니다. TPU의 Fetch Stage와 유사한 역할을 수행합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">Shred Verify Leader Signature Stage</div>
        <p>받은 shreds가 리더로부터 온 것인지 확인하기 위해 리더의 서명을 겁증합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">Retransmit Stage</div>
        <p>Turbine Tree에서의 위치에 따라 적절한 하위 검증자들에게 shreds를 전달합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">4</span>
        <div class="step-title">Replay Stage</div>
        <p>각 트랜잭션을 정확하고 올바른 순서로 재생성하면서 로컬 버전의 bank를 업데이트합니다.</p>
      </div>
    </div>
    
     
  </div>

  <div class="slide">
    <h2>Replay Stage: 핵심 검증 엔진</h2>
    <h3>Single-threaded Orchestration</h3>
    
    <p>Replay Stage는 TPU의 Banking Stage와 유사하며, TVU에서 가장 중요한 단계로 블록 검증 단계라고 직접적으로 설명할 수 있습니다. Replay는 투표, PoH 시계 재설정, bank 전환을 포함한 많은 핵심 작업을 조율하는 <strong>단일 스레드 프로세스 루프</strong>입니다.</p>
    
    <div class="diagram">
        <img src="images/replayStage.png" alt="Transaction Validation Unit">
      </div>

    
         <div class="highlight">
       <p><strong>핵심 기능:</strong> Replay Stage는 검증자를 리더 모드로 전환하고 블록 생산을 시작하는 책임을 가집니다. 이를 통해 솔라나의 연속적인 블록 생산 사이클이 유지됩니다.</p>
     </div>
   </div>

   <div class="slide">
    <h2>Security & Consensus Mechanisms</h2>
    <h3>Tower BFT + Proof of History</h3>

    <p>솔라나의 Tower BFT는 <strong>일관성보다 생존성(liveness)을 선호하는</strong> PBFT의 맞춤형 구현입니다. Tower BFT는 합의 전에 시계 역할을 하는 솔라나의 PoH를 활용하여 메시징 오버헤드와 지연 시간을 줄입니다.</p>
     
     <div class="highlight">
       <p><strong>핵심 혁신:</strong> "솔라나는 PBFT의 파생 구현을 사용하지만 하나의 근본적인 차이점이 있습니다. Proof of History(PoH)가 합의 전에 글로벌 시간 소스를 제공합니다. 우리의 PBFT 구현은 PoH를 네트워크 시계로 사용하며, PBFT에서 복제본이 사용하는 지수적으로 증가하는 타임아웃이 PoH 자체에서 계산되고 강제될 수 있습니다."</p>
     </div>
    
    <p>솔라나는 PBFT(Practical Byzantine Fault Tolerance) 기반의 Tower BFT 합의 메커니즘과 PoH를 결합하여 높은 보안성과 효율성을 동시에 달성합니다.</p>


    <p>poh가 어떻게 도와줄까?</p>
    <p>1. pbft보다 나은점 서로 시간증명위한 메시지 교환 필요 없다.... 이더리움 또한 필요 없는데? </p>
    <p>2. 초고빈도 블록에서도 시간/순서 증명 받을 수 있어 vote를 줄일 수 있다.</p>

    <div class="diagram">
      <img src="images/PBFT.png" alt="PBFT vs Solana Consensus">
    </div>
    
 
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">PoH 기반 시간 동기화</div>
        <p>모든 노드가 PoH 해시 체인을 통해 글로벌 시계를 공유합니다. 이로 인해 시간 증명에 대한 별도의 합의 과정이 불필요해집니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">포크 확률 최소화</div>
        <p>슬롯마다 단 하나의 리더만 블록을 제안할 수 있으며, 전 노드가 PoH로 시간 동기화하여 동일 높이에서 서로 다른 상태가 존재할 가능성을 낮춥니다.</p>
      </div>
    </div>
   </div>




       <div class="slide">
      <h2>Lockout Mechanism: Progressive Commitment</h2>
      <h3>Exponential Doubling & Slashing-Backed Security</h3>
      
      <p>검증자가 슬롯 s에 투표할 때, <strong>lockout 카운터 L(s)</strong>를 부착합니다. 이 메커니즘은 검증자가 특정 포크에 대한 커밋을 점진적으로 강화하도록 설계되었습니다.</p>
      
      <div class="feature-grid">
        <div class="feature-card">
          <div class="feature-title">Lockout 규칙</div>
          <ul>
            <li><strong>초기 lockout:</strong> L(s) = 1로 시작</li>
            <li><strong>후손 투표 시:</strong> 동일 검증자가 슬롯 s+k(후손)에 투표하면 모든 조상의 lockout이 이배화: L ← 2L</li>
            <li><strong>투표 금지:</strong> lockout이 만료되지 않은 슬롯과 충돌하는 포크에는 투표 불가</li>
            <li><strong>만료 조건:</strong> L(s) 추가 슬롯이 지나면 lockout 만료</li>
          </ul>
        </div>
      </div>
      

      
      <p>이 메커니즘을 통해 동일한 포크에서 여러 번 연속 투표한 후에는 이전 슬롯들이 매우 높은 lockout을 축적하게 되어 사실상 최종화됩니다. 검증자가 이러한 높은 lockout을 가진 슬롯을 롤백하려면 자신의 활성 lockout을 위반해야 하므로 슬래싱이 발생합니다.</p>
      
      <p>실제 lockout이 어떻게 진행되는지 구체적인 예시를 통해 살펴보겠습니다. 검증자가 연속적으로 같은 포크에 투표할 때마다 이전 투표들의 lockout이 2배로 증가합니다.</p>
      
      <div class="comparison-container">
        <div class="comparison-card">
          <div class="comparison-title" style="color: #9945FF;">🟣 투표 진행 과정</div>
          <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
            <tr style="background-color: #f0f0f0; border: 1px solid #ddd;">
              <th style="padding: 8px; border: 1px solid #ddd;">투표 슬롯</th>
              <th style="padding: 8px; border: 1px solid #ddd;">투표 후 Lockout</th>
              <th style="padding: 8px; border: 1px solid #ddd;">만료 시점 (추가 슬롯)</th>
            </tr>
            <tr style="border: 1px solid #ddd;">
              <td style="padding: 8px; border: 1px solid #ddd;">100</td>
              <td style="padding: 8px; border: 1px solid #ddd;">1</td>
              <td style="padding: 8px; border: 1px solid #ddd;">101에서 만료</td>
            </tr>
            <tr style="border: 1px solid #ddd;">
              <td style="padding: 8px; border: 1px solid #ddd;">101</td>
              <td style="padding: 8px; border: 1px solid #ddd;">2</td>
              <td style="padding: 8px; border: 1px solid #ddd;">103까지 유효</td>
            </tr>
            <tr style="border: 1px solid #ddd;">
              <td style="padding: 8px; border: 1px solid #ddd;">102</td>
              <td style="padding: 8px; border: 1px solid #ddd;">4</td>
              <td style="padding: 8px; border: 1px solid #ddd;">106까지 유효</td>
            </tr>
            <tr style="border: 1px solid #ddd;">
              <td style="padding: 8px; border: 1px solid #ddd;">103</td>
              <td style="padding: 8px; border: 1px solid #ddd;">8</td>
              <td style="padding: 8px; border: 1px solid #ddd;">111까지 유효</td>
            </tr>
            <tr style="border: 1px solid #ddd;">
              <td style="padding: 8px; border: 1px solid #ddd;">104</td>
              <td style="padding: 8px; border: 1px solid #ddd;">16</td>
              <td style="padding: 8px; border: 1px solid #ddd;">120까지 유효</td>
            </tr>
          </table>
        </div>
      </div>
      
      <div class="feature-grid">
        <div class="feature-card">
          <div class="feature-title">기하급수적 증가</div>
          <ul>
            <li><strong>5번째 투표 후:</strong> 첫 번째 슬롯의 lockout = 16</li>
            <li><strong>10번째 투표 후:</strong> 첫 번째 슬롯의 lockout = 512</li>
            <li><strong>20번째 투표 후:</strong> 첫 번째 슬롯의 lockout = 524,288</li>
            <li><strong>32번째 투표 후:</strong> 첫 번째 슬롯의 lockout = 2³² = 약 54년</li>
          </ul>
        </div>
       
      </div>

      <div class="feature-card">
        <div class="feature-title">슬래싱 보장</div>
        <ul>
          <li><strong>커밋 강제:</strong> 검증자는 활성 lockout을 위반하면 슬래싱 당함</li>
          <li><strong>이중 투표 방지:</strong> 충돌하는 포크에 동시 투표 불가능</li>
          <li><strong>경제적 처벌:</strong> lockout 위반 시 지분 손실</li>
          <li><strong>네트워크 보안:</strong> 악의적 행동에 대한 강력한 경제적 디센티브</li>
        </ul>
      </div>
      
      <div class="highlight">
        <p><strong>핵심 인사이트:</strong> 이 exponential doubling 메커니즘은 검증자들이 한 번 특정 포크에 커밋하면 계속해서 같은 방향으로 투표하도록 강력한 경제적 인센티브를 제공합니다.</p>
      </div>
    </div>

    <div class="slide">
        <h2>Fork Choice: Heaviest Lockout Weight</h2>
      
        <p>Solana가 여러 블록 포크 중 <strong>가장 안전</strong>한 체인을 선택하는 방식</p>
      
        <ul>
          <li><em>Lockout</em>: 투표가 되돌릴 수 없는 기간(슬롯이 증가할수록 2× 지수적으로 늘어남)</li>
          <li><em>Weight</em>: 남은 Lockout 길이 × 해당 투표의 스테이크</li>
          <li>포크별 모든 투표의 Weight를 누적 → <strong>가장 무거운(Heaviest)</strong> 포크 승리</li>
          <li>검증인은 그 포크에 새 블록을 추가하고 투표</li>
        </ul>
      
        <h3>안전성이 확보되는 이유</h3>
        <ul>
          <li>스테이크와 시간 둘 다 묶여 있어 롤백 비용 급증</li>
          <li>악의적 포크가 추월하려면 동일 Weight 필요 → 경제적 억지력</li>
        </ul>
      
        <h3>공식</h3>
        <p>\[Weight_{fork} = \sum_{i=1}^{n} Stake_i \times Remaining\;Lockout_i\]</p>
      </div>
      

    <div class="slide">
        <h2>Rooting &amp; Deterministic Finality</h2>
        <h3>2/3 Stake + 32-Vote Lock-out Guarantee</h3>
      
        <p>
          슬롯 <em>s</em>가 <strong>super-majority root</strong>(= Finalized)가 되기 위해서는 두 조건을
          모두 충족해야 합니다. 이는 솔라나가 확률적이 아닌
          <strong>결정론적 최종성</strong>을 제공하는 핵심 메커니즘입니다.
        </p>
      
        <!-- Rooting 조건 / Slashing 보안 -->
        <div class="feature-grid">
          <div class="feature-card">
            <div class="feature-title">Rooting 조건</div>
            <ul>
              <li><strong>2/3 지분 투표:</strong> ≥ 66 % 지분이 슬롯 s 에 투표</li>
              <li><strong>32-Vote Lock-out:</strong> s 위로 <u>연속 31 개</u> 후속 슬롯에 동일 지분이
                  투표하여 s 의 <code>lockout = 32</code> 도달</li>
              <li><strong>후손 슬롯 투표:</strong> 위 31 개 슬롯 역시 ≥ 2/3 투표</li>
              <li><strong>롤백 불가:</strong> 이후 s 를 롤백하려면 1/3 초과 지분이
                  고의로 lock-out 위반(= 슬래싱) 필요</li>
            </ul>
          </div>
      
          <div class="feature-card">
            <div class="feature-title">슬래싱 기반 보안</div>
            <ul>
              <li><strong>경제적 처벌:</strong> lock-out 위반 시 스테이크 슬래싱</li>
              <li><strong>수학적 보장:</strong> 2/3 초과 지분이 동시에 슬래싱될
                  확률은 경제적으로 불가능</li>
              <li><strong>결정론적 최종성:</strong> 조건 충족 즉시 네트워크 전체에서
                  불가역으로 고정</li>
            </ul>
          </div>
        </div>
      
        <!-- 단계별 흐름 -->
        <div class="flow-container">
          <div class="flow-step">
            <span class="step-number">1</span>
            <div class="step-title">초기 투표 (Confirmed)</div>
            <p>슬롯 s 가 네트워크의 ≥ 66 % 지분으로부터 첫 투표를 받아
               <strong>Confirmed</strong> 상태가 됩니다.</p>
          </div>
      
          <div class="flow-step">
            <span class="step-number">2</span>
            <div class="step-title">31 개 후속 슬롯 투표</div>
            <p>동일한 검증자들이 s 의 후손 31 슬롯에 연속 투표해
               lock-out 을 32 까지 더블링합니다.</p>
          </div>
      
          <div class="flow-step">
            <span class="step-number">3</span>
            <div class="step-title">Super-majority Root 검증</div>
            <p>네트워크가 두 조건(2/3 투표 + 32-vote lock-out) 충족을 확인합니다.</p>
          </div>
      
          <div class="flow-step">
            <span class="step-number">4</span>
            <div class="step-title">Finalized 선언</div>
            <p>조건이 만족되면 슬롯 s 가 <strong>Finalized</strong> 로 선언되며,
               이후 롤백은 경제적으로 불가능합니다.</p>
          </div>
        </div>
      
        <!-- 통계 카드 -->
        <div class="stats-grid">
          <div class="stat-card">
            <span class="stat-number">≥ 2/3</span>
            <div class="stat-label">필요 지분 비율</div>
          </div>
          <div class="stat-card">
            <span class="stat-number">32</span>
            <div class="stat-label">필요 Lock-out 깊이</div>
          </div>
          <div class="stat-card">
            <span class="stat-number">32&nbsp;슬롯</span>
            <div class="stat-label">평균 최종화 슬롯 수</div>
          </div>
          <div class="stat-card">
            <span class="stat-number">≈ 13&nbsp;초</span>
            <div class="stat-label">평균 최종화 시간</div>
          </div>
        </div>
      
        <!-- 비교 카드 -->
        <div class="comparison-container">
          <div class="comparison-card">
            <div class="comparison-title" style="color:#FF6B6B;">🔴 확률적 최종성 (PoW)</div>
            <ul>
              <li>시간이 지날수록 롤백 확률 감소</li>
              <li>통계적 확률 의존</li>
              <li>명확한 최종 지점 없음</li>
              <li>긴 확인 시간 필요</li>
            </ul>
          </div>
          <div class="comparison-card">
            <div class="comparison-title" style="color:#9945FF;">🟣 결정론적 최종성 (Solana)</div>
            <ul>
              <li>2/3 투표 + 32-vote lock-out 충족 시 확정</li>
              <li>슬래싱 기반 경제적 보장</li>
              <li>수학적으로 롤백 불가</li>
              <li>평균 13 초 내 확정적 최종성</li>
            </ul>
          </div>
        </div>
      
      </div>
 


   <div class="slide">
     <h2>Transaction States & Finality</h2>
     <h3>From Processed to Finalized</h3>
     
     <p>솔라나에서 트랜잭션의 상태는 합의 과정에서의 현재 단계에 따라 달라집니다.</p>
     
     <div class="flow-container">
       <div class="flow-step">
         <span class="step-number">1</span>
         <div class="step-title">Processed</div>
         <p>트랜잭션이 블록에 포함되었습니다.</p>
       </div>
       <div class="flow-step">
         <span class="step-number">2</span>
         <div class="step-title">Confirmed</div>
         <p>트랜잭션의 블록이 2/3 초다수에 의해 투표되었습니다.</p>
       </div>
       <div class="flow-step">
         <span class="step-number">3</span>
         <div class="step-title">Finalized</div>
         <p>트랜잭션의 블록 위에 31개 이상의 블록이 구축되었습니다.</p>
       </div>
     </div>
     
     <div class="stats-grid">
       <div class="stat-card">
         <span class="stat-number">2/3</span>
         <div class="stat-label">Confirmed를 위한 초다수 비율</div>
       </div>
       <div class="stat-card">
         <span class="stat-number">31+</span>
         <div class="stat-label">Finalized를 위한 블록 수</div>
       </div>
       <div class="stat-card">
         <span class="stat-number">100%</span>
         <div class="stat-label">Confirmed 블록의 Finalized 성공률</div>
       </div>
       <div class="stat-card">
         <span class="stat-number">0</span>
         <div class="stat-label">역사상 롤백된 Confirmed 블록 수</div>
       </div>
     </div>
     
     
     <div class="highlight">
       <p><strong>역사적 안정성:</strong> 현재까지 솔라나 역사상 confirmed된 블록이 최종화되지 않은 사례는 단 한 번도 없었습니다.</p>
     </div>
   </div>



  

  <div class="slide">
    <h2>Solana: The Future of Web3 Infrastructure</h2>
    <h3>Executive Summary & Roadmap</h3>
    
    <p>솔라나는 "소프트웨어는 하드웨어의 방해가 되어서는 안 된다"는 핵심 원칙 하에, 수십 년의 분산 시스템 구축 경험을 바탕으로 통합적 접근을 통해 블록체인 기술을 발전시키고 있습니다.</p>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">🎯 성능 우수성</div>
        <p>65,000+ TPS, 400ms 블록 시간, $0.00025 평균 수수료로 업계 최고 성능을 자랑하며, 사용자 경험과 개발자 효율성을 동시에 달성합니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">🏗️ 통합 아키텍처</div>
        <p>브리징, 별도 체인 ID, 유동성 분편화 없이 모든 애플리케이션이 하나의 블록체인에서 구축되어 진정한 컴포저빌리티를 실현합니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">🔮 미래 기술</div>
        <p>SVM 롤업과 ZK Compression 등 중요한 확장 솔루션이 개발 중이며, 미래 인식을 형성할 잠재력을 가지고 있습니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">🌟 생태계 혁신</div>
        <p>Firedancer 클라이언트, Jito MEV 인프라, 리퀴드 스테이킹 등을 통해 지속적으로 생태계를 발전시키고 있습니다.</p>
      </div>
    </div>
    
    <div class="stats-grid">
      <div class="stat-card">
        <span class="stat-number">4,000+</span>
        <div class="stat-label">RPC 노드</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">1,800+</span>
        <div class="stat-label">검증자 노드</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">80%</span>
        <div class="stat-label">Jito 클라이언트 사용률</div>
      </div>
      <div class="stat-card">
        <span class="stat-number">99.9%</span>
        <div class="stat-label">네트워크 가동률</div>
      </div>
    </div>
    
    <ul>
      <li><strong>기술적 우수성:</strong> PoH, Tower BFT, Turbine, Gulfstream 등 혁신적 기술 조합</li>
      <li><strong>개발자 친화성:</strong> Rust 기반 개발, 풍부한 SDK, 직관적 계정 모델</li>
      <li><strong>경제적 효율성:</strong> 낮은 수수료, 예측 가능한 비용, 다양한 스테이킹 옵션</li>
      <li><strong>확장성 해결:</strong> 복잡한 Layer2 없이 Layer1에서 직접 확장성 달성</li>
      <li><strong>미래 준비:</strong> 지속적인 혁신과 생태계 발전으로 Web3 대중화 주도</li>
    </ul>
    
    <div class="highlight">
      <p><strong>최종 전망:</strong> 솔라나는 "크립토의 애플"이 될 잠재력을 가지고 있으며, 나스닥과 뉴욕 증권거래소와 경쟁할 수 있는 속도로 뉴스가 전 세계를 여행하는 만큼 빠르게 트랜잭션을 처리하는 것을 목표로 합니다. 주류 소비자 앱을 지원할 수 있는 오늘날 유일한 체인으로 인식되고 있으며, Web3 생태계의 미래를 이끌어가고 있습니다.</p>
    </div>
    
    <p class="note">Solana는 PoH, Gulfstream, Banking Stage, Turbine의 혁신적 조합으로 블록체인 트릴레마(확장성, 보안성, 탈중앙화)를 해결했습니다. 멤풀 없는 아키텍처, 병렬 처리 엔진, 효율적인 합의 메커니즘을 통해 차세대 분산 애플리케이션을 위한 고성능 인프라를 제공하며, 웹3 생태계의 대중화를 이끌어가고 있습니다.</p>
  </div>

  <div class="slide">
    <h1>솔라나 개발</h1>
  </div>

  <div class="slide">
    <h2>목차</h2>
    <h3>주요 학습 내용</h3>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">솔라나 계정 모델</div>
        <p>데이터 저장 방식, 시스템 프로그램, PDA 개념</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">트랜잭션과 인스트럭션</div>
        <p>AccountMeta, 병렬 처리, SOL 전송 예제</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">Anchor 프레임워크</div>
        <p>주요 매크로, 계정 검증, 프로그램 구조</p>
      </div>
      <div class="flow-step">
        <span class="step-number">4</span>
        <div class="step-title">실습: 투표 시스템</div>
        <p>단계별 구현, PDA 설계, 시간 검증</p>
      </div>
      <div class="flow-step">
        <span class="step-number">5</span>
        <div class="step-title">Orca DEX 분석</div>
        <p>프로덕션 코드 구조, 실무 패턴</p>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>솔라나 계정이란?</h2>
    <h3>솔라나 데이터 모델의 기초</h3>
    
    <div class="diagram">
      <img src="images/Account.png" alt="솔라나 계정 구조">
    </div>
    
    <p>솔라나에서는 모든 데이터가 <strong>"계정(accounts)"</strong>이라고 불리는 곳에 저장됩니다. 솔라나의 데이터를 단일 "계정" 테이블이 있는 공개 데이터베이스로 생각할 수 있으며, 이 테이블의 각 항목이 "계정"입니다. 모든 솔라나 계정은 동일한 기본 계정 타입을 공유합니다.</p>
    

    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">핵심 속성</div>
        <ul>
          <li><strong>데이터 저장:</strong> 최대 10MiB 데이터 저장 가능 (실행 코드 또는 프로그램 상태)</li>
          <li><strong>임대료 요구사항:</strong> 저장된 데이터에 비례하는 램포트 보증금 필요</li>
          <li><strong>프로그램 소유권:</strong> 모든 계정은 지정된 프로그램 소유자를 가짐</li>
          <li><strong>권한 모델:</strong> 소유자 프로그램만 데이터 수정 또는 잔액 차감 가능</li>
        </ul>
      </div>
      <div class="feature-card">
        <div class="feature-title">계정 분류</div>
        <ul>
          <li><strong>시스템 계정:</strong> 네트워크 클러스터 상태 정보 저장</li>
          <li><strong>프로그램 계정:</strong> 스마트 컨트랙트의 실행 코드 저장</li>
          <li><strong>데이터 계정:</strong> 프로그램이 상태를 저장하고 관리하기 위해 생성</li>
          <li><strong>Sysvar 계정:</strong> 네트워크 클러스터 상태를 가진 특수 계정</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>계정 주소 체계와 구조</h2>
    <h3>고유 식별 시스템</h3>
    
    <div class="diagram">
      <img src="images/Account2.png" alt="계정 주소 체계">
    </div>
    
    <p>솔라나의 모든 계정은 고유한 32바이트 주소를 가지며, 이는 보통 base58 인코딩된 문자열로 표시됩니다 (예: <code>14grJpemFaf88c8tiVb77W7TYg2W3ir6pfkKz3YjhhZ5</code>).</p>

    <div class="comparison-container">
      <div class="comparison-card">
        <div class="comparison-title" style="color: #9945FF;">🟣 Ed25519 공개키</div>
        <ul>
          <li>가장 일반적인 계정 주소 유형</li>
          <li>암호화 키 쌍에서 생성</li>
          <li>지갑 계정과 사용자 제어 계정에 사용</li>
          <li>공개키에서 파생된 32바이트 주소</li>
        </ul>
      </div>
    </div>
    
    <div class="code-block">
// 예시: Ed25519 키 쌍 생성
use solana_sdk::signer::{keypair::Keypair, Signer};

let keypair = Keypair::new();
println!("공개키: {}", keypair.pubkey());
println!("개인키: {:?}", keypair.to_bytes());
    </div>
  </div>

  <div class="slide">
    <h2>기본 계정 타입 구조</h2>
    <h3>범용 계정 필드</h3>
    
    <p>계정의 최대 크기는 10MiB이며, 솔라나의 모든 계정은 5개의 필수 필드를 가진 동일한 기본 계정 타입을 공유합니다.</p>
    
    <div class="code-block">
pub struct Account {
    /// 계정의 램포트 잔액
    pub lamports: u64,
    /// 이 계정에 저장된 데이터
    pub data: Vec&lt;u8&gt;,
    /// 이 계정을 소유하는 프로그램
    pub owner: Pubkey,
    /// 이 계정의 데이터가 실행 가능한 프로그램인지 여부
    pub executable: bool,
    /// 이 계정이 다음 임대료를 지불해야 하는 에포크 (더 이상 사용되지 않음)
    pub rent_epoch: Epoch,
}
    </div>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">Lamports 필드</div>
        <p>램포트 단위의 계정 잔액 (SOL의 최소 단위: 1 SOL = 10억 램포트). 계정의 SOL 잔액을 나타내며 데이터 저장에 필요한 최소 임대료 보증금을 포함합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">Data 필드</div>
        <p>임의의 데이터를 저장하는 바이트 배열. 프로그램 계정의 경우 실행 코드를 포함하고, 데이터 계정의 경우 소유 프로그램이 정의한 상태 정보를 저장합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">Owner 필드</div>
        <p>이 계정을 소유하는 프로그램의 ID (공개키). 소유자 프로그램만이 계정 데이터를 수정하거나 램포트 잔액을 차감할 수 있습니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">4</span>
        <div class="step-title">Executable 필드</div>
        <p>계정이 실행 가능한 프로그램 코드를 포함하는지를 나타내는 불린 값. 프로그램 계정은 true, 상태를 저장하는 데이터 계정은 false입니다.</p>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>시스템 프로그램과 계정 생성</h2>
    <h3>계정 관리의 기반</h3>
    
    <div class="diagram">
      <img src="images/Systemprogram.png" alt="시스템 프로그램">
    </div>
    
    <p>기본적으로 프로그램이 아닌 계정은 시스템 프로그램이 소유합니다. 시스템 프로그램은 계정 생명주기 관리에 중요한 기능을 수행하며, 솔라나에서 새 계정을 생성할 수 있는 유일한 프로그램입니다.</p>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">시스템 프로그램 기능</div>
        <ul>
          <li><strong>새 계정 생성:</strong> 계정을 생성할 수 있는 유일한 프로그램</li>
          <li><strong>공간 할당:</strong> 계정 데이터 필드의 바이트 용량 설정</li>
          <li><strong>소유권 할당:</strong> 다른 프로그램으로 소유권 이전 가능</li>
          <li><strong>SOL 전송:</strong> 계정 간 램포트 전송</li>
        </ul>
      </div>
    
    </div>
    
    <div class="highlight">
      <p><strong>시스템 프로그램 주소:</strong> <code>11111111111111111111111111111111</code></p>
      <p>새 주소로 SOL이 처음 전송되면, 해당 주소에 시스템 프로그램이 소유하는 계정이 자동으로 생성됩니다.</p>
    </div>
  </div>

  <div class="slide">
    <h2>프로그램 계정과 로더</h2>
    <h3>실행 코드 저장</h3>
    
    <div class="diagram">
      <img src="images/BPFLoader.png" alt="BPF 로더">
    </div>
    
    <p>솔라나 프로그램을 배포하면 프로그램 코드를 저장하는 실행 가능한 프로그램 계정이 생성됩니다. 프로그램 계정은 System Program이 생성하여 소유권을 BPFLoader에게 넘겨줍니다. 로더 프로그램은 실행 가능한 프로그램 계정을 로드하고 관리하는 역할을 하는 내장 프로그램 역할을 합니다.</p>

    
    owner: BPFLoader2111111111111111111111111111111111,
  </div>

  <div class="slide">
    <h2>데이터 계정과 상태 관리</h2>

    <div class="diagram">
        <img src="images/DataAccount.png" alt="BPF 로더">
      </div>

    <h3>프로그램 상태 저장</h3>
    
    <p>솔라나에서는 실행 코드와 프로그램 상태가 별도로 저장됩니다. 프로그램은 자신이 소유하는 데이터 계정을 생성하는 명령어를 정의하며, 각 계정은 고유한 주소를 가지고 프로그램이 정의한 임의의 데이터를 저장할 수 있습니다.</p>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">계정 생성 요청</div>
        <p>커스텀 프로그램이 시스템 프로그램에 지정된 크기와 임대료 보증금으로 새 계정 생성을 요청합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">시스템 프로그램이 계정 생성</div>
        <p>시스템 프로그램이 계정을 생성하고 초기에 소유하며, 데이터 필드에 요청된 공간을 할당합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">소유권 이전</div>
        <p>시스템 프로그램이 새로 생성된 계정의 소유권을 요청한 커스텀 프로그램으로 이전합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">4</span>
        <div class="step-title">데이터 초기화</div>
        <p>이제 소유자가 된 커스텀 프로그램이 정의된 구조와 로직에 따라 계정 데이터를 초기화합니다.</p>
      </div>
    </div>
    
    <div class="highlight">
      <p><strong>핵심 원칙:</strong> 시스템 프로그램만이 새 계정을 생성할 수 있습니다. 생성 후 소유권을 커스텀 프로그램으로 이전할 수 있으며, 이후 해당 프로그램이 자신의 프로그램 로직에 따라 계정의 데이터와 상태를 관리합니다.</p>
    </div>
    </div>
    <div class="slide">
        <h2>Sysvar 계정</h2>
        <h3>네트워크 클러스터 상태 접근</h3>
        
        <p>Sysvar 계정은 클러스터 상태 데이터에 대한 접근을 제공하는 미리 정의된 주소의 특수 계정입니다. 이러한 계정은 네트워크 클러스터에 대한 정보로 동적으로 업데이트되며 모든 프로그램에서 사용할 수 있습니다.</p>
        
        <div class="feature-grid">
          <div class="feature-card">
            <div class="feature-title">Clock Sysvar</div>
          </div>
          <div class="feature-card">
            <div class="feature-title">Rent Sysvar</div>
          </div>
          <div class="feature-card">
            <div class="feature-title">Stake History Sysvar</div>
          </div>
          <div class="feature-card">
            <div class="feature-title">Recent Blockhashes</div>
          </div>
        </div>
    </div>
    
    <div class="slide">
    <h2>rent와 저장소</h2>
    <h3>계정 저장소 비용 모델</h3>
    
    <p>온체인에 데이터를 저장하려면 계정은 저장된 데이터 양에 비례하는 램포트(SOL) 잔액을 유지해야 합니다. 이 잔액을 "임대료"라고 하지만, 회수 가능한 보증금처럼 작동합니다.</p>
    
    <div class="feature-grid">
        <div class="feature-card">
        <div class="feature-title">개발자 고려사항</div>
        <ul>
            <li><strong>데이터 최적화:</strong> 임대료 비용을 줄이기 위해 데이터 최적화</li>
            <li><strong>계정 재사용:</strong> 가능한 경우 계정 재사용</li>
            <li><strong>생명주기 계획:</strong> 계정 생성 및 닫기 계획</li>
            <li><strong>비용 계산:</strong> 임대료 계산기를 사용하여 비용 예측</li>
        </ul>
        </div>
    </div>
    </div>

  <div class="slide">
    <h2>Transaction과 Instruction</h2>

    <div class="diagram">
        <img src="images/Transaction.png" alt="AccountMeta 구조">
      </div>

    <h3>네트워크와 상호작용</h3>
    
    <div class="diagram">
      <img src="images/Transaction2.png" alt="Transaction 구조">
    </div>
    
    <p>솔라나에서 사용자는 네트워크와 상호작용하기 위해 Transaction을 전송합니다. Transaction은 처리할 작업을 지정하는 하나 이상의 Instruction을 포함합니다. Instruction의 실행 로직은 솔라나 네트워크에 배포된 프로그램에 저장되며, 각 프로그램은 자체 Instruction 집합을 정의합니다.</p>
    
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">Transaction 핵심 특징</div>
        <ul>
          <li><strong>다중 Instruction:</strong> 하나의 Transaction에 여러 Instruction 포함 가능</li>
          <li><strong>실행 순서:</strong> Instruction은 Transaction에 추가된 순서대로 실행</li>
          <li><strong>원자성:</strong> 모든 Instruction이 성공해야 하며, 하나라도 실패하면 전체 Transaction 실패</li>
          <li><strong>프로그램 호출:</strong> 네트워크의 프로그램을 호출하는 Instruction 포함</li>
        </ul>
      </div>
      <div class="feature-card">
        <div class="feature-title">Instruction 필수 정보</div>
        <ul>
          <li><strong>프로그램 주소:</strong> 호출할 프로그램의 주소</li>
          <li><strong>계정 목록:</strong> Instruction이 읽거나 쓸 계정들</li>
          <li><strong>추가 데이터:</strong> Instruction에 필요한 추가 데이터 (함수 인수 등)</li>
          <li><strong>권한 정보:</strong> 계정의 서명자 및 쓰기 가능 여부</li>
        </ul>
      </div>
    </div>
    
    <div class="highlight">
      <p><strong>비유:</strong> Transaction은 양식이 들어있는 봉투로 생각할 수 있습니다. 각 양식은 네트워크에 무엇을 할지 알려주는 Instruction입니다. Transaction을 보내는 것은 양식을 처리하기 위해 봉투를 우편으로 보내는 것과 같습니다.</p>
    </div>

    이더리움은 하나의 계정에 State + Program 둘 다 있는데 솔라나는 두개의 계정으로 나눈다 왜??  <br>
    --> 최대한 잘게 쪼개서 병렬 처리성을 높일 수 있다. Read Write를 구분도 가능

    성능을 높이려면 불편을 감수해야하는데 
  </div>

  <div class="slide">
    <h2>SOL 전송 예제</h2>
    <h3>시스템 프로그램 호출</h3>
    
    <div class="diagram">
      <img src="images/Transaction3.png" alt="SOL 전송">
    </div>
    
    <p>아래 다이어그램은 발신자에서 수신자로 SOL을 전송하는 단일 Instruction이 있는 Transaction을 나타냅니다. 솔라나에서 "지갑"은 시스템 프로그램이 소유하는 계정입니다. 프로그램 소유자만 계정의 데이터를 변경할 수 있으므로, SOL 전송에는 시스템 프로그램을 호출하는 Transaction 전송이 필요합니다.</p>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">Transaction 서명</div>
        <p>발신자 계정이 Transaction에 서명(is_signer)하여 시스템 프로그램이 자신의 램포트 잔액을 차감할 수 있도록 허용합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">계정 권한 설정</div>
        <p>발신자와 수신자 계정은 모두 램포트 잔액이 변경되므로 쓰기 가능(is_writable)해야 합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">시스템 프로그램 처리</div>
        <p>Transaction 전송 후, 시스템 프로그램이 전송 Instruction을 처리하고 발신자와 수신자 계정의 램포트 잔액을 업데이트합니다.</p>
      </div>
    </div>
    
    <div class="diagram">
      <img src="images/Transaction4.png" alt="SOL 전송 과정">
    </div>
  </div>


  <div class="slide">
    <h2>AccountMeta</h2>
    <h3>계정 메타데이터와 권한</h3>
    
    <div class="diagram">
      <img src="images/AccountMeta.png" alt="AccountMeta 구조">
    </div>
    
    <p>명령어를 생성할 때 필요한 각 계정을 <code>AccountMeta</code>로 제공해야 합니다. AccountMeta는 계정의 공개키, 서명 필요 여부, 쓰기 가능 여부를 지정합니다.</p>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">pubkey</div>
        <p>계정의 주소를 나타내는 공개키입니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">is_signer</div>
        <p>계정이 트랜잭션에 서명해야 하는지를 나타냅니다. true인 경우 해당 계정의 개인키로 트랜잭션에 서명해야 합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">is_writable</div>
        <p>명령어가 계정의 데이터를 수정하는지를 나타냅니다. true인 경우 계정의 데이터나 메타데이터가 변경될 수 있습니다.</p>
      </div>
    </div>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">병렬 실행의 핵심</div>
        <ul>
          <li><strong>사전 명시:</strong> 명령어가 읽거나 쓸 계정을 미리 지정</li>
          <li><strong>계정 충돌 방지:</strong> 동일한 계정을 수정하지 않는 트랜잭션들은 병렬 실행</li>
          <li><strong>성능 향상:</strong> 솔라나의 높은 TPS를 가능하게 하는 핵심 메커니즘</li>
          <li><strong>예측 가능성:</strong> 실행 전에 어떤 계정이 영향받을지 알 수 있음</li>
        </ul>
      </div>
      <div class="feature-card">
        <div class="feature-title">개발자 편의성</div>
        <ul>
          <li><strong>클라이언트 라이브러리:</strong> 대부분의 프로그램이 헬퍼 함수 제공</li>
          <li><strong>자동 생성:</strong> 명령어를 수동으로 구성할 필요 없음</li>
          <li><strong>타입 안전성:</strong> 잘못된 계정 구성을 컴파일 시점에 방지</li>
          <li><strong>문서화:</strong> 프로그램 구현을 참조하여 필요한 계정 확인</li>
        </ul>
      </div>
    </div>
    
    <div class="highlight">
      <p><strong>실제 사용:</strong> 실제로는 명령어를 수동으로 구성할 필요가 거의 없습니다. 대부분의 프로그램 개발자는 명령어를 생성해주는 헬퍼 함수가 있는 클라이언트 라이브러리를 제공합니다. 어떤 계정이 필요한지, 어떤 계정이 쓰기 가능하거나 읽기 전용이어야 하는지, 또는 트랜잭션에 서명해야 하는지를 알려면 프로그램에서 정의한 명령어의 구현을 참조해야 합니다.</p>
    </div>
  </div>

  <div class="slide">
    <h2>Program Derived Address (PDA)</h2>
    <h3>결정론적 주소 생성과 프로그램 서명</h3>
    
    <p>Program Derived Address (PDA)는 솔라나 개발에서 두 가지 주요 용도로 사용되는 기능입니다: <strong>결정론적 계정 주소 생성</strong>과 <strong>프로그램 서명 활성화</strong>입니다.</p>
    

    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">PDA의 핵심 특징</div>
        <ul>
          <li><strong>결정론적 생성:</strong> 선택적 시드와 프로그램 ID 조합으로 항상 동일한 주소 생성</li>
          <li><strong>해시맵 구조:</strong> 미리 정의된 입력(문자열, 숫자, 계정 주소)으로 온체인 해시맵 생성</li>
          <li><strong>주소 추적 불필요:</strong> 정확한 주소 기억 대신 파생에 사용된 입력만 기억하면 됨</li>
          <li><strong>프로그램 서명:</strong> 솔라나 런타임이 프로그램을 대신해 PDA에 서명 가능</li>
        </ul>
      </div>

    </div>
    
  </div>

  <div class="slide">
    <h2>PDA 파생 과정</h2>
    <h3>3가지 입력으로 주소 생성</h3>
    
    <p>PDA 파생에는 세 가지 입력이 필요합니다:</p>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">선택적 시드 (Optional Seeds)</div>
        <p>PDA 파생을 위한 미리 정의된 입력들 (문자열, 숫자, 다른 계정 주소 등). 이 시드들은 바이트로 변환되어 사용됩니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">Bump 시드</div>
        <p>유효한 PDA(곡선 밖)가 생성되도록 보장하기 위해 선택적 시드에 추가되는 추가 바이트입니다. 255에서 시작하여 유효한 PDA를 찾을 때까지 1씩 감소합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">프로그램 ID</div>
        <p>PDA가 파생되는 프로그램의 주소입니다. 이 프로그램이 PDA를 대신하여 서명할 수 있습니다.</p>
      </div>
    </div>
    
    <div class="diagram">
        <img src="images/PDA.png" alt="SOL 전송 과정">
      </div>
    
    장점 : 1. 주소 기억 불필요 ex) 참가자 1번의 데이터가 있는 주소 위치 = PDA로 알아낼 수 있다. <br>
            2. 프라이빗 키 기억할 필요 없다. ownership을 프로그램에 종속시켜 키관리 불필요. 

  </div>


  <div class="slide">
    <h2>Solana 개발 흐름</h2>
    <h3>Rust와 Anchor 프레임워크</h3>
    
    <p>Solana 개발은 주로 Rust 언어와 Anchor 프레임워크를 사용하여 이루어집니다. 이는 고성능과 안전성을 보장하면서도 개발 효율성을 높여줍니다.</p>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">개발 환경 설정</div>
        <p>Rust 설치 후 Anchor 프레임워크를 설정합니다. Anchor는 이더리움의 Truffle/Hardhat/Foundry와 같은 역할을 하며 개발 과정을 간소화해줍니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">프로그램 작성</div>
        <p>Rust로 함수들을 작성하고 필요한 상태(Struct)를 정의합니다. 각 함수가 어떤 계정에 읽기/쓰기 접근을 하는지 명시해야 합니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">빌드 및 컴파일</div>
        <p>작성한 프로그램을 BPF 바이트코드로 컴파일합니다. Anchor CLI가 이 과정을 자동화해줍니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">4</span>
        <div class="step-title">클러스터 배포</div>
        <p>컴파일된 프로그램을 솔라나 클러스터에 배포합니다. 성공하면 프로그램 주소(Program ID)가 발급됩니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">5</span>
        <div class="step-title">계정 생성 및 초기화</div>
        <p>프로그램이 사용할 계정들을 생성하고 초기 데이터를 설정합니다 (토큰 발행량, NFT 메타데이터 등).</p>
      </div>
    </div>
    
    
  </div>

  <div class="slide">
    <h1>Anchor 프레임워크 배우기</h1>
    <h3>솔라나 프로그램 개발을 위한 고급 도구</h3>
    
    <p>Anchor는 솔라나 프로그램 개발을 위한 프레임워크로, Rust 매크로를 사용하여 보일러플레이트 코드를 줄이고 솔라나 프로그램 작성에 필요한 일반적인 보안 검사를 단순화합니다.</p>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">주요 매크로</div>
        <ul>
          <li><strong>declare_id!:</strong> 프로그램의 온체인 주소 지정</li>
          <li><strong>#[program]:</strong> 명령어 로직을 포함하는 모듈 지정</li>
          <li><strong>#[derive(Accounts)]:</strong> 명령어 필요 계정 목록 정의</li>
          <li><strong>#[account]:</strong> 프로그램용 커스텀 계정 타입 생성</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>프로그램 구조와 주요 매크로</h2>
    <h3>Anchor 프로그램의 기본 구조</h3>
    
    <p>Anchor 프로그램에서 발견되는 주요 매크로들을 실제 예제를 통해 살펴보겠습니다:</p>
    
    <div class="code-block">
use anchor_lang::prelude::*;

// 1. 프로그램 ID 선언
declare_id!("11111111111111111111111111111111");

// 2. 프로그램 모듈과 명령어 핸들러
#[program]
mod hello_anchor {
    use super::*;
    
    pub fn initialize(ctx: Context&lt;Initialize&gt;, data: u64) -> Result&lt;()&gt; {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }
}

// 3. 계정 구조체 정의 (명령어에 필요한 계정들)
#[derive(Accounts)]
pub struct Initialize&lt;'info&gt; {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account&lt;'info, NewAccount&gt;,
    #[account(mut)]
    pub signer: Signer&lt;'info&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}

// 4. 커스텀 계정 타입 정의
#[account]
pub struct NewAccount {
    data: u64,
}
    </div>
    
    <div class="highlight">
      <p><strong>예제 설명:</strong> 위 프로그램은 새 계정(NewAccount)을 생성하고 u64 값으로 초기화하는 단일 명령어 `initialize`를 포함합니다. 각 매크로는 특정한 역할을 수행하여 개발 과정을 단순화합니다.</p>
    </div>
  </div>

  <div class="slide">
    <h2>declare_id! 매크로</h2>
    <h3>프로그램 주소 지정</h3>
    
    <div class="code-block">
use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");
    </div>
    
    <p><code>declare_id</code> 매크로는 프로그램 ID라고 알려진 프로그램의 온체인 주소를 지정합니다. 기본적으로 프로그램 ID는 <code>/target/deploy/your_program_name.json</code>에서 생성된 키 쌍의 공개키입니다.</p>
    
    
  </div>

  <div class="slide">
    <h2>#[program] 속성</h2>
    <h3>명령어 핸들러 모듈</h3>
    
    <p><code>#[program]</code> 속성은 프로그램의 모든 명령어 핸들러를 포함하는 모듈에 적용됩니다. 이 모듈 내의 각 공개 함수는 호출할 수 있는 명령어에 해당합니다.</p>
    
    <div class="code-block">
#[program]
mod hello_anchor {
    use super::*;
    
    pub fn initialize(ctx: Context&lt;Initialize&gt;, data: u64) -> Result&lt;()&gt; {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }
}
    </div>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">명령어 핸들러</div>
        <p>명령어가 호출될 때 실행되는 로직을 정의하는 함수입니다. 첫 번째 매개변수는 항상 <code>Context&lt;T&gt;</code> 타입입니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">추가 매개변수</div>
        <p>명령어가 호출될 때 제공되어야 하는 인수를 지정하는 선택적 매개변수들입니다.</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">반환값</div>
        <p>모든 명령어 핸들러는 <code>Result&lt;()&gt;</code> 타입을 반환하여 성공 또는 오류를 나타냅니다.</p>
      </div>
    </div>
  </div>


  <div class="slide">
    <h2>#[derive(Accounts)] 매크로</h2>
    <h3>계정 검증과 직렬화</h3>
    
    <p><code>#[derive(Accounts)]</code> 매크로는 명령어가 호출될 때 제공되어야 하는 계정들을 지정하는 구조체에 적용됩니다.</p>
    
    <div class="code-block">
#[derive(Accounts)]
pub struct Initialize&lt;'info&gt; {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account&lt;'info, NewAccount&gt;,
    #[account(mut)]
    pub signer: Signer&lt;'info&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}
    </div>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">필드 명명</div>
        <p>구조체의 각 필드는 명령어에 필요한 계정을 나타냅니다. 필드 이름은 임의적이지만, 계정의 목적을 나타내는 설명적인 이름을 사용하는 것이 권장됩니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">계정 제약</div>
        <p><code>#[account(..)]</code> 속성을 사용하여 계정이 명령어에 유효한 것으로 간주되기 위해 만족해야 하는 추가 조건을 정의할 수 있습니다.</p>
      </div>
    </div>
    
    <div class="highlight">
      <p><strong>자동 검증:</strong> Anchor 프로그램에서 명령어가 호출되면, 프로그램은 먼저 제공된 계정들을 검증한 후 명령어의 로직을 실행합니다.</p>
    </div>
  </div>

  <div class="slide">
    <h2>#[account] 속성</h2>
    <h3>커스텀 계정 타입 정의</h3>
    
    <p><code>#[account]</code> 속성은 프로그램에서 생성한 커스텀 계정에 저장되는 데이터의 구조를 정의하는 구조체에 적용됩니다.</p>
    
    <div class="code-block">
#[account]
pub struct NewAccount {
    data: u64,
}
    </div>
    
    <div class="feature-grid">
    
    </div>

  </div>


  <div class="slide">
    <h2>Solidity -> Anchor</h2>

    아래 간단한 솔리디티 코드를 살펴보자. 
    
    <div class="code-block">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract SimpleCounter {
    mapping(address => uint64) public value;      

    // Solana initialize와 동일: 처음 한 번만 값 설정
    function initialize(uint64 data) external {
        value[msg.sender] = data;
    }

    // Solana add와 동일: (전달한 값 + 1) 로 덮어쓰기
    function add(uint64 data) external {
        value[msg.sender] = data + 1;
    }
}
  </div>

위의 솔리디티 코드를 Anchor 솔라나 프로그램으로 바꾸어 본다면??? 


<div class="code-block">
use anchor_lang::prelude::*;

declare_id!("7PDDZHoXz5MDJQeBY2V28QRFGnM3iKGgDurHrdbg7LJj");

#[program]
mod hello_anchor {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }

    pub fn add(ctx: Context<Add>, data: u64) -> Result<()> {
        ctx.accounts.created_account.data = data + 1;
        msg!("Changed data to: {}!", ctx.accounts.created_account.data);
        Ok(())
    }

}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8, seeds = [b"counter", signer.key().as_ref()], bump) ]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Add<'info> {
    #[account(
        mut,
        seeds = [b"counter", signer.key().as_ref()],
        bump
    )]
    pub created_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[account]
pub struct NewAccount {
    data: u64,
}

</div>

  </div>

  <div class="slide">
    <h1>실습: 투표 시스템 구축하기</h1>
    <h3>단계별 Anchor 프로그램 개발</h3>
    
    <p>실제 투표 시스템을 통해 Anchor 프로그램 개발의 전체 과정을 단계별로 살펴보겠습니다. 이 예제는 설문조사를 생성하고, 후보자를 추가하며, 투표하는 완전한 시스템입니다.</p>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">🗳️ 핵심 기능</div>
        <ul>
          <li><strong>설문 생성:</strong> 시작/종료 시간과 함께 새 투표 생성</li>
          <li><strong>후보자 추가:</strong> 투표에 참여할 후보자들 등록</li>
          <li><strong>투표 실행:</strong> 시간 제한 내에서 후보자에게 투표</li>
          <li><strong>시간 검증:</strong> 투표 시작/종료 시간 자동 확인</li>
        </ul>
      </div>
      <div class="feature-card">
        <div class="feature-title">🔧 학습 포인트</div>
        <ul>
          <li><strong>PDA 활용:</strong> 결정론적 주소로 계정 관리</li>
          <li><strong>시드 설계:</strong> poll_id와 candidate 이름 조합</li>
          <li><strong>시간 검증:</strong> Clock sysvar를 통한 시간 확인</li>
          <li><strong>에러 처리:</strong> 커스텀 에러 코드 정의</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>Step 1: 계정 구조 설계</h2>
    <h3>각 함수별 필요 계정 매핑</h3>
    
    <p>먼저 각 함수가 어떤 계정들을 사용하는지 체계적으로 분석해보겠습니다:</p>
    
    <div class="comparison-container">
      <div class="comparison-card">
        <div class="comparison-title" style="color: #1a73e8;">📊 PollAccount</div>
        <ul>
          <li><strong>Seeds:</strong> ["poll", poll_id]</li>
          <li><strong>용도:</strong> 투표의 기본 정보 저장</li>
          <li><strong>데이터:</strong> 이름, 설명, 시작/종료시간, 옵션 수</li>
          <li><strong>생명주기:</strong> initialize_poll에서 생성</li>
        </ul>
      </div>
      <div class="comparison-card">
        <div class="comparison-title" style="color: #34a853;">🙋 CandidateAccount</div>
        <ul>
          <li><strong>Seeds:</strong> [poll_id, candidate_name]</li>
          <li><strong>용도:</strong> 각 후보자의 투표 수 저장</li>
          <li><strong>데이터:</strong> 후보자 이름, 득표 수</li>
          <li><strong>생명주기:</strong> initialize_candidate에서 생성</li>
        </ul>
      </div>
    </div>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">initialize_poll 함수</div>
        <p><strong>사용 계정:</strong> Signer + PollAccount (생성) + SystemProgram</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">initialize_candidate 함수</div>
        <p><strong>사용 계정:</strong> Signer + PollAccount (읽기) + CandidateAccount (생성) + SystemProgram</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">vote 함수</div>
        <p><strong>사용 계정:</strong> Signer + PollAccount (읽기) + CandidateAccount (수정)</p>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>Step 2: 데이터 구조 정의</h2>
    <h3>Account 구조체 설계</h3>
    
    <p>투표 시스템에 필요한 두 가지 주요 데이터 구조를 정의합니다:</p>
    
    <div class="code-block">#[account]
#[derive(InitSpace)]
pub struct PollAccount {
    #[max_len(32)]
    pub poll_name: String,           // 투표 제목 (최대 32자)
    #[max_len(280)]
    pub poll_description: String,    // 투표 설명 (최대 280자)
    pub poll_voting_start: u64,      // 투표 시작 시간 (Unix timestamp)
    pub poll_voting_end: u64,        // 투표 종료 시간 (Unix timestamp)
    pub poll_option_index: u64,      // 후보자 수 카운터
}

#[account]
#[derive(InitSpace)]
pub struct CandidateAccount {
    #[max_len(32)]
    pub candidate_name: String,      // 후보자 이름 (최대 32자)
    pub candidate_votes: u64,        // 득표 수
}</div>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">InitSpace 매크로</div>
        <p><code>#[derive(InitSpace)]</code>는 Anchor v0.30+에서 도입된 기능으로, 계정에 필요한 공간을 자동으로 계산합니다. <code>#[max_len(n)]</code> 속성과 함께 사용하여 String 필드의 최대 길이를 지정할 수 있습니다.</p>
      </div>
      <div class="feature-card">
        <div class="feature-title">공간 계산</div>
        <p>PollAccount: 8(판별자) + 4+32(이름) + 4+280(설명) + 8+8+8(시간들) = 352바이트<br>
        CandidateAccount: 8(판별자) + 4+32(이름) + 8(투표수) = 52바이트</p>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>Step 3: 첫 번째 함수 - initialize_poll</h2>
    <h3>투표 생성 기능</h3>
    
    <div class="code-block">pub fn initialize_poll(ctx: Context<InitializePoll>, 
                        _poll_id: u64, 
                        start_time: u64, 
                        end_time: u64,
                        name: String,
                        description: String) -> Result<()> {
    ctx.accounts.poll_account.poll_name = name;
    ctx.accounts.poll_account.poll_description = description;
    ctx.accounts.poll_account.poll_voting_start = start_time;
    ctx.accounts.poll_account.poll_voting_end = end_time;
    Ok(())
}

#[derive(Accounts)]
#[instruction(poll_id: u64)]
pub struct InitializePoll<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,

    #[account(
        init_if_needed,
        payer = signer,
        space = 8 + PollAccount::INIT_SPACE,
        seeds = [b"poll".as_ref(), poll_id.to_le_bytes().as_ref()],
        bump
    )]
    pub poll_account: Account<'info, PollAccount>,

    pub system_program: Program<'info, System>,
}</div>
    
    <div class="flow-container">
      <div class="flow-step">
        <span class="step-number">1</span>
        <div class="step-title">PDA 생성</div>
        <p>Seeds: ["poll", poll_id]를 사용하여 각 투표마다 고유한 주소 생성</p>
      </div>
      <div class="flow-step">
        <span class="step-number">2</span>
        <div class="step-title">계정 초기화</div>
        <p>init_if_needed 제약으로 이미 존재하지 않는 경우에만 계정 생성</p>
      </div>
      <div class="flow-step">
        <span class="step-number">3</span>
        <div class="step-title">데이터 설정</div>
        <p>투표 이름, 설명, 시작/종료 시간을 계정에 저장</p>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>Step 4: 두 번째 함수 - initialize_candidate</h2>
    <h3>후보자 추가 기능</h3>
    
    <div class="code-block">pub fn initialize_candidate(ctx: Context<InitializeCandidate>, 
                            _poll_id: u64, 
                            candidate: String) -> Result<()> {
    ctx.accounts.candidate_account.candidate_name = candidate;
    ctx.accounts.poll_account.poll_option_index += 1;
    Ok(())
}

#[derive(Accounts)]
#[instruction(poll_id: u64, candidate: String)]
pub struct InitializeCandidate<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,

    #[account(mut)]
    pub poll_account: Account<'info, PollAccount>,

    #[account(
        init,
        payer = signer,
        space = 8 + CandidateAccount::INIT_SPACE,
        seeds = [poll_id.to_le_bytes().as_ref(), candidate.as_ref()],
        bump
    )]
    pub candidate_account: Account<'info, CandidateAccount>,

    pub system_program: Program<'info, System>,
}</div>
    
    <div class="highlight">
      <p><strong>핵심 포인트:</strong> 이 함수는 두 개의 기존 계정과 상호작용합니다. PollAccount는 후보자 수를 증가시키기 위해 수정하고, CandidateAccount는 새로 생성합니다. Seeds 조합 [poll_id, candidate_name]으로 각 후보자마다 고유한 주소를 보장합니다.</p>
    </div>
  </div>

  <div class="slide">
    <h2>Step 5: 세 번째 함수 - vote</h2>
    <h3>투표 실행 및 시간 검증</h3>
    
    <div class="code-block">pub fn vote(ctx: Context<Vote>, _poll_id: u64, _candidate: String) -> Result<()> {
    let candidate_account = &mut ctx.accounts.candidate_account;
    let current_time = Clock::get()?.unix_timestamp;

    if current_time > (ctx.accounts.poll_account.poll_voting_end as i64) {
        return Err(ErrorCode::VotingEnded.into());
    }

    if current_time <= (ctx.accounts.poll_account.poll_voting_start as i64) {
        return Err(ErrorCode::VotingNotStarted.into());
    }

    candidate_account.candidate_votes += 1;
    Ok(())
}

#[derive(Accounts)]
#[instruction(poll_id: u64, candidate: String)]
pub struct Vote<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,

    #[account(
        mut,
        seeds = [b"poll".as_ref(), poll_id.to_le_bytes().as_ref()],
        bump,
    )]
    pub poll_account: Account<'info, PollAccount>,

    #[account(
        mut,
        seeds = [poll_id.to_le_bytes().as_ref(), candidate.as_ref()],
        bump
    )]
    pub candidate_account: Account<'info, CandidateAccount>,
}</div>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">시간 검증 로직</div>
        <ul>
          <li><strong>Clock Sysvar:</strong> 현재 시간을 얻기 위한 시스템 계정</li>
          <li><strong>투표 전:</strong> 아직 시작 시간이 되지 않음</li>
          <li><strong>투표 후:</strong> 이미 종료 시간이 지남</li>
          <li><strong>유효 시간:</strong> start_time ≤ now ≤ end_time</li>
        </ul>
      </div>
      <div class="feature-card">
        <div class="feature-title">에러 처리</div>
        <div class="code-block">#[error_code]
pub enum ErrorCode {
    #[msg("Voting has not started yet")]
    VotingNotStarted,
    #[msg("Voting has ended")]
    VotingEnded,
}</div>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>Step 6: 계정 관계도</h2>
    <h3>전체 시스템 아키텍처</h3>
    
    <div class="diagram" style="text-align: left; font-family: monospace; background: #f8f9fa; padding: 20px; border-radius: 8px;">
<pre>
투표 시스템 계정 구조:

┌─────────────────────────────────────────────────────────────┐
│                        Poll #1                              │
│  Seeds: ["poll", poll_id(1)]                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ PollAccount                                         │   │
│  │ • poll_name: "대통령 선거"                           │   │
│  │ • poll_description: "2024년 대선"                   │   │
│  │ • poll_voting_start: 1640995200                     │   │
│  │ • poll_voting_end: 1641081600                       │   │
│  │ • poll_option_index: 3                             │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  후보자들:                                                   │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐│
│  │CandidateAccount │ │CandidateAccount │ │CandidateAccount ││
│  │Seeds:[1,"김후보"]│ │Seeds:[1,"이후보"]│ │Seeds:[1,"박후보"]││
│  │name: "김후보"    │ │name: "이후보"    │ │name: "박후보"    ││
│  │votes: 150       │ │votes: 200       │ │votes: 100       ││
│  └─────────────────┘ └─────────────────┘ └─────────────────┘│
└─────────────────────────────────────────────────────────────┘

함수별 계정 접근:
• initialize_poll: PollAccount 생성
• initialize_candidate: PollAccount 읽기/수정 + CandidateAccount 생성  
• vote: PollAccount 읽기 + CandidateAccount 수정
</pre>
    </div>
    
    <div class="highlight">
      <p><strong>Seeds 설계 철학:</strong> PollAccount는 투표별로 하나만 존재해야 하므로 poll_id만 사용하고, CandidateAccount는 같은 투표 내에서 후보자별로 하나씩 존재해야 하므로 poll_id + candidate_name을 조합합니다.</p>
    </div>
  </div>

  <div class="slide">
    <h2>Step 7: 완전한 프로그램 코드</h2>
    <h3>모든 구성 요소 통합</h3>
    
    <div class="code-block">use anchor_lang::prelude::*;

        declare_id!("GA9KPeboU2E1Lrkq3bDSqgzMYvfPjCDaeP2hai2LxXN9");
        
        #[program]
        pub mod voting {
            use super::*;
        
            pub fn initialize_poll(ctx: Context<InitializePoll>, 
                                    _poll_id: u64, 
                                    start_time: u64, 
                                    end_time: u64,
                                    name: String,
                                    description: String) -> Result<()> {
                ctx.accounts.poll_account.poll_name = name;
                ctx.accounts.poll_account.poll_description = description;
                ctx.accounts.poll_account.poll_voting_start = start_time;
                ctx.accounts.poll_account.poll_voting_end = end_time;
                Ok(())
            }
        
            pub fn initialize_candidate(ctx: Context<InitializeCandidate>, 
                                        _poll_id: u64, 
                                        candidate: String) -> Result<()> {
                ctx.accounts.candidate_account.candidate_name = candidate;
                ctx.accounts.poll_account.poll_option_index += 1;
                Ok(())
            }
        
            pub fn vote(ctx: Context<Vote>, _poll_id: u64, _candidate: String) -> Result<()> {
                let candidate_account = &mut ctx.accounts.candidate_account;
                let current_time = Clock::get()?.unix_timestamp;
        
                if current_time > (ctx.accounts.poll_account.poll_voting_end as i64) {
                    return Err(ErrorCode::VotingEnded.into());
                }
        
                if current_time <= (ctx.accounts.poll_account.poll_voting_start as i64) {
                    return Err(ErrorCode::VotingNotStarted.into());
                }
        
                candidate_account.candidate_votes += 1;
        
                Ok(())
            }
            
        }
        
        #[derive(Accounts)]
        #[instruction(poll_id: u64)]
        pub struct InitializePoll<'info> {
            #[account(mut)]
            pub signer: Signer<'info>,
        
            #[account(
                init_if_needed,
                payer = signer,
                space = 8 + PollAccount::INIT_SPACE,
                seeds = [b"poll".as_ref(), poll_id.to_le_bytes().as_ref()],
                bump
            )]
            pub poll_account: Account<'info, PollAccount>,
        
            pub system_program: Program<'info, System>,
        }
        
        #[derive(Accounts)]
        #[instruction(poll_id: u64, candidate: String)]
        pub struct InitializeCandidate<'info> {
            #[account(mut)]
            pub signer: Signer<'info>,
        
            pub poll_account: Account<'info, PollAccount>,
        
            #[account(
                init,
                payer = signer,
                space = 8 + CandidateAccount::INIT_SPACE,
                seeds = [poll_id.to_le_bytes().as_ref(), candidate.as_ref()],
                bump
            )]
            pub candidate_account: Account<'info, CandidateAccount>,
        
            pub system_program: Program<'info, System>,
        }
        
        #[derive(Accounts)]
        #[instruction(poll_id: u64, candidate: String)]
        pub struct Vote<'info> {
            #[account(mut)]
            pub signer: Signer<'info>,
        
            #[account(
                mut,
                seeds = [b"poll".as_ref(), poll_id.to_le_bytes().as_ref()],
                bump,
            )]
            pub poll_account: Account<'info, PollAccount>,
        
            #[account(
                mut,
                seeds = [poll_id.to_le_bytes().as_ref(), candidate.as_ref()],
                bump)]
            pub candidate_account: Account<'info, CandidateAccount>,
        }
        
        #[account]
        #[derive(InitSpace)]
        pub struct CandidateAccount {
            #[max_len(32)]
            pub candidate_name: String,
            pub candidate_votes: u64,
        }
        
        #[account]
        #[derive(InitSpace)]
        pub struct PollAccount{
            #[max_len(32)]
            pub poll_name: String,
            #[max_len(280)]
            pub poll_description: String,
            pub poll_voting_start: u64,
            pub poll_voting_end: u64,
            pub poll_option_index: u64,
        }
        
        #[error_code]
        pub enum ErrorCode {
            #[msg("Voting has not started yet")]
            VotingNotStarted,
            #[msg("Voting has ended")]
            VotingEnded,
        }
    </div>
  </div>

  <div class="slide">
    <h1>Orca DEX 코드 구조 파악</h1>
    <h3>실제 프로덕션 Solana 프로그램 분석</h3>
    
    <p>Orca는 솔라나의 대표적인 탈중앙화 거래소(DEX)입니다. 실제 프로덕션에서 사용되는 Anchor 프로그램의 구조를 분석해보겠습니다.</p>
    
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">📊 분석 목표</div>
        <ul>
          <li>실제 DEX 프로그램 구조 이해</li>
          <li>복잡한 PDA 설계 패턴 학습</li>
          <li>프로덕션 레벨 코드 품질 확인</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="slide">
    <h2>Orca 프로그램 전체 구조</h2>
    <h3>메인 프로그램 파일 분석</h3>
    
    <p>Orca DEX의 핵심 프로그램 파일 구조를 살펴보겠습니다:</p>
    
    <!-- 코드 이미지 공간 1 -->
    <div class="diagram">
        <img src="images/orca-dex/orca-file.png" alt="SOL 전송 과정">
    </div>
  </div>

  <div class="slide">
    <h2>lib 구조</h2>
    
    <p>Orca의 lib를 살펴보겠습니다:</p>

    <div class="diagram">
        <img src="images/orca-dex/lib.png" alt="SOL 전송 과정">
    </div>
    
  </div>

  <div class="slide">
    <h2>Instruction 파일</h2>
    
    <p>Orca의 instruction:</p>
    
    <div class="diagram">
        <img src="images/orca-dex/initialize_config.png" alt="SOL 전송 과정">
    </div>

  </div>

  <div class="slide">
    <h2>그 외</h2>
    
    <p>필요한 함수들 다른 파일에 넣는다.. 컨트랙트가 커질수록 비교적 간단:</p>
    <div class="diagram">
        <img src="images/orca-dex/orca-file.png" alt="SOL 전송 과정">
    </div>
   
  </div>

  <div class="diagram">
    <img src="images/qr.png" alt="PBFT vs Solana Consensus">
  </div>

</body>
</html>